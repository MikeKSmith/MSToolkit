[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 MSToolkit authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/MSToolkit_intro_vig.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to MSToolkit","text":"MSToolkit R package designed built Pfizer Mango Solutions originally, used simulating data, analysing data assessing operating characteristics clinical trials. MSToolkit comprises suite low-level functions used generate data apply user-specified analysis functions SAS analysis code generated data. High level functions provided wrap functions together perform data generation analysis steps. purpose vignettes page help users understand generate data cases analyse simulated data.","code":""},{"path":"/articles/MSToolkit_intro_vig.html","id":"illustration-of-generatedate-function-by-an-example","dir":"Articles","previous_headings":"","what":"Illustration of generateDate function by an example","title":"Introduction to MSToolkit","text":"generateData function generates simulated data replicates controlling dosing, covariates, parameters, response, missingness interim. takes number arguments passed various lower level functions create sets simulated data. following inputs used generate 100 replicates 200 subjects split equally across two treatment arms basic linear model. treatment doses 0 100. Parameters ALPHA BETA generated ALPHA = 0 BETA = 1. values ALPHA BETA change simulation replicates since genParVCov = 0. linear predictor (respEqn) calculates response treatment (dose) according equation \\(ALPHA + BET * DOSE\\), case expected effect dose dose level since ALPHA=0 BETA=1. respVCov specifies response variability / residual error added expected values generated respEqn. residual variability equals 1 values N(0,1) distribution generated response added values respEqn. seed set ensure reproducibility. default MSToolkit assumes additive error structure, although can changed settings generateData(...) call. Meanwhile, different distributions specified respDist =: example simulate data binomial distribution setting respDist=\"Binary\". linear predictor given \\(log(\\frac{p}{1-p}) = ALPHA + BETA*DOSE\\), probability response equals 1 increases DOSE. canonical inverse link functions used convert linear predictor input response distribution, example link Binary data \\(\\frac{exp( x )}{1 + exp( x )}\\). link functions can specified setting argument respInvLink takes R function. example possible generate binary data explicit probabilities setting respDist = \"Binary\" respInvLink = \"NULL\" use identity link. Besides, different outcome values generated specifying linear predictor respEqn argument. valid R expression function. expression can written directly generateData R function defined outside generateData can called. function must return vector equal length number rows generated data - one value per subject one value per observation (TIME) within subject. basic Emax model applied generate 100 replicates 100 subjects split equally across 5 treatment arms. treatment arms 0, 5, 10, 50, 100. Three parameters generated, named E0, ED50 EMAX. take values 0, 50 100 respectively. variance-covariance matrix set 0 , parameters across replicates. linear predictor standard 3-parameter Emax model. variance response set 100 responses drawn Normal distribution mean given Emax model variance 100, example respVCov = 100. Instead setting variance-covariance matrix 0, set diagonal matrix variances vary model parameter values replicates, example genParVCov=diag(c(10,10,10)). case variance-covariance matrix set diagonal matrix variance 10 parameter. means E0 ~ N(0,10), ED50 ~ N(50,10) EMAX ~ N(100,10) values E0, ED50 EMAX replicate drawn Normal distributions. addition, include correlations parameters E0, ED50 EMAX. parameter variance equals 10 correlation ED50 EMAX 0.8, typical type model. Note variance-covariance matrix can specified number ways, array matrix, values lower triangle full variance-covariance matrix. MSToolkit automatically converts numbers full covariance matrix checks positive-semi-definite using function parseCovMatrix. Furthermore, specify proportion subjects interim cut (note proportions cumulative) including argument interimSubj. , first interim \\(\\frac{1}{3}\\) data, second \\(\\frac{2}{3}\\). Subjects randomly assigned interim proportions 1, 2, 3 probabilty \\(\\frac{1}{3}\\) . means may exactly \\(\\frac{1}{3}\\) subjects assigned interim, experience real life. also define function outside generateData specifying mean effects treatment. example, want precisely mean response experimental drug control treatment. function called resp.fn written calculate mean response subject takes data treatment identifier (TRT=1 2), DOSE information (DOSE=0 1, merely labels can ignored example). dataset also includes two parameters - MEAN1 MEAN2 values 0 10 respectively. resp.fn must take dataset return value RESP subject. function initialises value RESP (=0) treatment, assigns MEAN = 1 TRT = 1 MEAN = 10 TRT = 2.resulting values residual error added (respVCov=1). Besides, generate data crossover trial. , use function generate mean response subject, swap specifying RESP function TRT RESP function DOSE. specify crossover trial, TRT becomes treatment sequence subjects allocated , DOSE becomes treatment identifier period. dose drug, simply label (since means defined exactly treatment). use argument treatType=\"Crossover\" show generating data crossover trial use treatSeq define treatment sequences. treatSeq array, can specify number treatment periods sequences using labels treatments given treatDoses, 0 1 . array sequences columns periods rows. specified 2x2 crossover two sequences, DOSE = 0 followed DOSE = 1 vice versa. three-period, two-treatment design specified treatSeq=array(c(0,1,1,1,0,0),dim=c(3,2)). must also take little extra care thinking data generation processes crossover trials. crossover can assume treatment effect constant across treatment periods, usually assume individual’s responses periods correlated - subjects high observations period 1 high observations period 2. specifying subject variability parameter means genParBtwNames = \"MEAN1,MEAN2\", genParBtwVCov = c(1,0.8,1) genParErrStruc = \"Additive\". options add subject variability MEAN1 MEAN2 correlation 0.8 . Thus subjects high MEAN1 also high MEAN2. Finally residual error added respVCov usual. , analysis, look treatment effects within subjects can also look period effects sequence effects (none simulated ). last, MSToolkit creates sub-directory called ReplicateData current R working directory output generateData function. individual replicate datasets stored CSV format directory named replicate000x.csv. 9999 replicate datasets can created.","code":"# Before we use the `generateDate` function, we need to library the `MSToolkit` package.  library(MSToolkit)  # Inputs the variables into the arguments  generateData(replicateN = 100,               subjects = 200,               treatSubj = rep(100,2),               treatDoses = c(0,100),                genParNames = \"ALPHA, BETA\",               genParMean = c(0,1),               genParVCov = 0,                respEqn = \"ALPHA+BETA*DOSE\",               respVCov = 1,                seed = 12345) generateData(replicateN = 2,               subjects = 200,               treatSubj = rep(100,2),               treatDoses = c(0,100),                genParNames = \"ALPHA, BETA\",               genParMean = c(0,1),               genParVCov = c(1,1),               respEqn = \"ALPHA+BETA*DOSE\",                respDist = \"Binary\")    # Binomial distribution generateData(replicateN = 100,               subjects = 100,               treatSubj = rep(20,5),              treatDoses = c(0, 5, 10, 50, 100),                genParNames = \"E0,ED50,EMAX\",               genParMean = c(0,50,100),               genParVCov = diag(c(0,0,0)),                respEqn = \"E0 + ((DOSE * EMAX)/(DOSE + ED50))\",                respVCov = 100) generateData(replicateN = 100,               subjects = 100,               treatSubj = rep(20,5),              treatDoses = c(0, 5, 10, 50, 100),                genParNames = \"E0,ED50,EMAX\",               genParMean = c(0,50,100),               genParVCov = diag(c(10,10,10)),                respEqn = \"E0 + ((DOSE * EMAX)/(DOSE + ED50))\",                respVCov = 100) generateData(replicateN = 100,               subjects = 100,               treatSubj = rep(20,5),              treatDoses = c(0, 5, 10, 50, 100),                genParNames = \"E0,ED50,EMAX\",               genParMean = c(0,50,100),               genParVCov = c(10,1,10,1,8,10),                respEqn = \"E0 + ((DOSE * EMAX)/(DOSE + ED50))\",                respVCov = 100) generateData(replicateN = 2,               subjects = 100,               treatSubj = rep(20,5),              treatDoses = c(0, 5, 10, 50, 100),                genParNames = \"E0,ED50,EMAX\",               genParMean = c(0,50,100),               genParVCov = c(10,1,10,1,8,10),              respEqn = \"E0 + ((DOSE * EMAX)/(DOSE + ED50))\",                respVCov = 100,                interimSubj = c(0.33,0.66)) resp.fn<-function(data){     RESP<-rep(0,nrow(data))     RESP[data$TRT == 1] <- data$MEAN1[data$TRT == 1]     RESP[data$TRT == 2] <- data$MEAN2[data$TRT == 2]     RESP     }      generateData(replicateN = 2,               subjects = 200,               treatSubj = rep(100,2),               treatDoses = c(0,1),                genParNames = \"MEAN1, MEAN2\",               genParMean = c(0,10),               genParVCov = 0,                respEqn = resp.fn,               respVCov = 1) resp.fn<-function(data){     RESP<-rep(0,nrow(data))     RESP[data$DOSE == 0]<-data$MEAN1[data$DOSE == 0]     RESP[data$DOSE == 1]<-data$MEAN2[data$DOSE == 1]     RESP     } generateData(replicateN = 2,               subjects = 20,               treatSubj = rep(10,2),               treatDoses = c(0,1),              treatType = \"Crossover\",               treatSeq = array(c(0,1,1,0),dim=c(2,2)),                genParNames = \"MEAN1, MEAN2\",               genParMean = c(0,10),               genParVCov = 0,                genParBtwNames = \"MEAN1,MEAN2\",              genParBtwVCov = c(1,0.8,1),              genParErrStruc = \"Additive\",                respEqn = resp.fn,               respVCov = 1)"},{"path":"/articles/MSToolkit_intro_vig.html","id":"illustration-of-analyzedata-function-by-an-example","dir":"Articles","previous_headings":"","what":"Illustration of analyzeData function by an example","title":"Introduction to MSToolkit","text":", analyzeData function illustrated completed example, included data generation process, data analysis process decision criteria.","code":""},{"path":[]},{"path":"/articles/MSToolkit_intro_vig.html","id":"design","dir":"Articles","previous_headings":"Illustration of analyzeData function by an example > Data generation","what":"Design","title":"Introduction to MSToolkit","text":"design study follows: 100 subjects Parallel group 5 doses: Placebo, 5, 10, 50, 100mg (units arbitrary example) Patients allocated randomly dose (.e. guarantee equal allocation treatment arm). Interim analyses 30% 70% subjects provided response","code":""},{"path":"/articles/MSToolkit_intro_vig.html","id":"response-generation-function","dir":"Articles","previous_headings":"Illustration of analyzeData function by an example > Data generation","what":"Response generation function","title":"Introduction to MSToolkit","text":"E0 ~ N(2, 0.5) ED50 ~ N(50, 30) EMAX ~ N(10,10) Additive (.e. Y = RESP + residual error)","code":""},{"path":"/articles/MSToolkit_intro_vig.html","id":"simulation-specification","dir":"Articles","previous_headings":"Illustration of analyzeData function by an example > Data generation","what":"Simulation specification","title":"Introduction to MSToolkit","text":"5 trial replicates Simulate model parameter uncertainty (.e. replicate unique values model parameters, drawn underlying multivariate distribution). case, model parameters independent (.e. -diagonal elements multivariate variance-covariance matrix zero). apply information generateDatafunction simulate data:","code":"generateData(   replicateN = 5,   subjects = 100,   treatDoses = c(0, 5, 10, 50, 100),   genParNames = \"E0, ED50, EMAX\",   genParMean = c(2, 50, 10),   genParVCov = c(0.5, 30, 10),   respEqn = \"E0 + ((DOSE * EMAX)/(DOSE + ED50))\",   respVCov = 2,   interimSubj = \"0.3, 0.7\")"},{"path":"/articles/MSToolkit_intro_vig.html","id":"evaluation-of-operating-characteristics","dir":"Articles","previous_headings":"Illustration of analyzeData function by an example","what":"Evaluation of operating characteristics","title":"Introduction to MSToolkit","text":"executing data analysis, need introduce concept -operating characteristics. Operating characteristics refer performance given design + analysis + decision criteria. usually interested probability making correct decisions (correct GO correct GO) probabilities making false positive false negative decisions separately. Many factors can influence probabilities: Dose-selection numbers subjects influence precision estimated parameters. choice model model selection process. handle estimation observed data match priori model selection. decision criteria whether based purely estimated mean whether involves interval estimates.","code":""},{"path":"/articles/MSToolkit_intro_vig.html","id":"micro-evaluation-of-a-priori-effect-vs-simulated-observed","dir":"Articles","previous_headings":"Illustration of analyzeData function by an example > Evaluation of operating characteristics","what":"Micro-evaluation of a priori effect vs simulated / “observed”","title":"Introduction to MSToolkit","text":"MSToolkit introduce idea micro-evaluation (treatment specific comparison priori known effects “truth” vs simulated trial, “observed” estimated effects). Micro-evaluation help characterise bias precision estimated parameters treatment effects. use help refine analytical methods - aim reduce bias increase precision estimates given data generation + analysis method. Note good practice investigate micro-evaluation properties “null” data generation cases .e. prior effect. usually also look sensitivity priori assumptions. can varying data generation model compared assumptions made analysis method. can include generating data non-monotonic increasing functions analysis assumes monotonically increasing dose-response functions.","code":""},{"path":"/articles/MSToolkit_intro_vig.html","id":"macro-evaluation-to-assess-decision-criteria","dir":"Articles","previous_headings":"Illustration of analyzeData function by an example > Evaluation of operating characteristics","what":"Macro-evaluation to assess decision criteria","title":"Introduction to MSToolkit","text":"MSToolkit also uses call “macro-evaluation” assess operating characteristics decision criteria. Macro-evaluation aims make overall decision “success” “failure” trial. Usually macro-evaluation decision criteria compares decision made simulated trial data decision made given perfect information prior known “truth”.","code":""},{"path":[]},{"path":"/articles/MSToolkit_intro_vig.html","id":"defining-the-analysiscode-function","dir":"Articles","previous_headings":"Illustration of analyzeData function by an example > Performing data analysis by using R function","what":"Defining the analysisCode function","title":"Introduction to MSToolkit","text":"example code using function emax.fit perform basic analysis. function allows access many summaries model fit data. replicate datasets passed function argument data. Analysis output (micro-evaluation datasets named micro000x.csv) stored MicroEvaluation sub-directory within working directory. One dataset stored replicate. analyzeData function collates individual micro000x.csv files single MicroSummary.csv data file last replicate analyzed. MicroSummary.csv file stored top level working directory.","code":"emaxCode <- function(data) {      uniDoses <- sort(unique(data$DOSE))   obsMean <- tapply(data$RESP,                      list(data$DOSE), mean)   obsSD <- tapply(data$RESP,                   list(data$DOSE), sd)   eFit <- emax.fit(data$RESP, data$DOSE)   outDf <- data.frame(DOSE = uniDoses,                       MEAN = eFit$fitpred,                       SE = eFit$sdpred,                       SDDIF = eFit$sddif)      outDf$LOWER <- outDf$MEAN - 1.96 * outDf$SE   outDf$UPPER <- outDf$MEAN + 1.96 * outDf$SE   outDf$N <- table(data$DOSE)   outDf$OBSMEAN <- obsMean   outDf$OBSSD <- obsSD   outDf }"},{"path":"/articles/MSToolkit_intro_vig.html","id":"interim-analysis","dir":"Articles","previous_headings":"Illustration of analyzeData function by an example > Performing data analysis by using R function","what":"Interim analysis","title":"Introduction to MSToolkit","text":"NOTE need specify interim analysis proportions generated data analyze replicate dataset. subjects assigned interim cuts generated data, interim analysis steps carried (analyzeData function assumes subjects full dataset). interimcode function run analysisCode specified interim analysis function specifies rules dropping doses terminating study. REQUIRED outputs DROP STOP. code checks whether lower confidence limit difference placebo dose zero .e. difference placebo. DROP variable vector doses dropped study. STOP flag indicates whether study stop. case, doses included DROP (including placebo) study stopped. micro-evaluation dataset micro000x.csv found MicroEvaluation sub-directory (see ) compiles together results analysis interim. contains column INTERIM indicates interim analysis results pertain . INTERIM==0 denotes analysis FULL dataset (.e. doses dropped assuming study goes completion). allows us compare adaptive design non-adaptive design one step. , interim evaluation drop dose, DROPPED=1 dose subjects dose included evaluation subsequent interims. Information dose already gained carried forward subsequent interim analysis updated new model evaluation, dose remain closed allocation. micro000x.csv dataset also includes STOPPED variable indicates specific interim analysis study stopped. Note perform analysis FULL (100%) dataset conducting interim analyses decision made stop study can compare results comparable data without interim analysis.","code":"interimCode <- function(data) { # DROP any doses where the lower bound of the difference from placebo is negative   dropdose  <- with(data, DOSE [LOWER < 0 & DOSE != 0])   outList <- list()   if (length(dropdose) > 0)      outList$DROP <- dropdose   outList$STOP <- length(dropdose) == nrow(data) - 1   outList }"},{"path":"/articles/MSToolkit_intro_vig.html","id":"marco-evaluation-code","dir":"Articles","previous_headings":"Illustration of analyzeData function by an example > Performing data analysis by using R function","what":"Marco-evaluation code","title":"Introduction to MSToolkit","text":"macro-evaluation code looks lower confidence limits difference placebo values less zero declares trial failure. least ONE confidence limits zero trial deemed success. MacroEvaluation directory contains results macro-evaluation (macroCode output) replicate macro000x.csv dataset. analyzeData function compiles MacroSummary.csv file stored top level working directory. macroCode function can return macro-evaluation summary useful assessing trial-level operating characteristics, like success failure, bias precision parameter estimates, etc.","code":"macroCode <- function(data) {   # Is effect at highest dose significant?   success <-      data$LOWER[data$INTERIM == max(data$INTERIM) & data$DOSE == max(data$DOSE)] > 7   data.frame(SUCCESS = success) }"},{"path":"/articles/MSToolkit_intro_vig.html","id":"running-analysis-using-analyzedata","dir":"Articles","previous_headings":"Illustration of analyzeData function by an example > Performing data analysis by using R function","what":"Running analysis using analyzeData","title":"Introduction to MSToolkit","text":"analyzeData wraps analysis micro-evaluation, macro-evaluation interim analysis functions together controls input output replicate data (replicate000x.csv ReplicateData subdirectory), passing analysis function (argument data) returning micro-evaluation output micro000x.csv replicate MicroEvaluation subdirectory. also applies macro-evaluation function micro000x dataset, generating macro000x.csv dataset stored MacroEvaluation subdirectory. interim analysis requested, analyzeData function apply analysisCode function first full dataset, interim cut data. interim cut (including FULL dataset analysis) interimCode function applied decide whether DROP doses STOP study.","code":"analyzeData(analysisCode = emaxCode,             macroCode = macroCode,             interimCode = interimCode)  # analysisCode and macroCode are REQUIRED inputs."},{"path":"/articles/MSToolkit_intro_vig.html","id":"performing-data-analysis-by-using-sas-code","dir":"Articles","previous_headings":"Illustration of analyzeData function by an example","what":"Performing data analysis by using SAS code","title":"Introduction to MSToolkit","text":"also apply SAS code analyzeData function. using SAS code perform analysis, code MUST placed TOP level working directory. code written accept working input dataset called INFILE return final dataset results called OUTFILE. datasets contained WORK directory (.e. permanent SAS datasets). Code written robust errors. user’s responsibility track errors within SAS code. call external SAS code analysis following syntax used: macroCode functions can written R. SAS output passed back R macro-evaluation carried replicate though analysis carried R. example ran following SAS analysis code. code analyses generated data using basic PROC NLIN call. example interested assessing model fit parameters “true” values used data generation. use SAS ODS system create dataset model parameters.","code":"analyzeData(analysisCode = \"emax.sas\",              software = \"SAS\",              macroCode = macrocode) ods output parameterestimates=parms corrb=corr; proc nlin;  model resp=e0 + (emax * dose) / (ed50 + dose);  # Specify the form of the Emax equation;  parameters e0 = 0 ed50 = 25 emax = 120;  # Specify starting values for the parameters;  bounds ed50 > 0;   # Set up boundary conditions.  Here ED50 must be positive; run; ods output close; proc transpose data=parms out=tparms prefix=mean;  var estimate;  id parameter;  run; proc transpose data=parms out=stderr prefix=se;  var estimate;  id parameter;  run; proc sql noprint;  create table doses as    select unique(dose) as dose    from infile;  create table parms2 as    select * from tparms t, stderr s;  create table doseparms as    select * from doses d, tparms t, stderr s;  create table obsvars as    select mean(resp) as dsm, var(resp) as dsv,count(resp) as n    from infile    group by dose; quit; data outfile (drop=_name_);  retain mean se lower upper 0;  set doseparms;  mean=0;  se=0;  lower=0;  upper=0;  n=0;  run;"},{"path":"/articles/MSToolkit_intro_vig.html","id":"troubleshooting-the-analysis-code","dir":"Articles","previous_headings":"","what":"Troubleshooting the analysis code","title":"Introduction to MSToolkit","text":"troubleshoot analysis interim code macro-evaluation code can read individual dataset code: run analysisCode function (.e. EmaxCode function generated ) Output EmaxCode function micro-evaluation dataset. However doesn’t return right dataset ’s easier troubleshoot running 100 replicates. can check macroCode function reading micro-evaluation dataset: run macroCode function (.e. macroCode function generated ) : ’re happy , can go look interimCode works running: full analysis micro-evaluation step interims well full dataset. NOTE need specify interim analysis proportions generated data analyze replicate dataset. subjects assigned interim cuts generated data, interim analysis steps carried (analyzeData function assumes subjects FULL dataset).","code":"data <- readData( dataNumber = 1, dataType = \"Replicate\") EmaxCode(data) data <- read.csv(\"./microevaluation/micro0001.csv\")  # The micro-evaluation dataset is stored in the MicroEvaluation sub-directory  # within the working directory macroCode(data) analyzeRep(analysisCode = emaxCode,            interimCode = interimcode,            replicate = 1)"},{"path":"/articles/analyze_data.html","id":"how-it-works","dir":"Articles","previous_headings":"","what":"How it works","title":"analyzeData","text":"analyzedata(...) performs analysis individual replicate datasets. Get started page gives overview analysis process, short analyzeData(…) function analyses replicate dataset turn applies user defined analysisCode function supplied analyse data. analysisCode function need written context analysing single dataset. MSToolkit takes care reading replicate dataset writing back analysis results. user must provide valid R function used analysing generated dataset external file (.R .SAS) contains code analysis data. user must also provide functions performing micro- macro-evaluation summary trial performance. analyzedata(...) function automatically handles data input output, pointing analytic function (analysisCode) replicate dataset turn. user doesn’t need explicitly name “replicate000x.csv” file analysis. analyzedata(...) takes user-defined analysisCode function loops replicate dataset turn passing analysisCode function takes argument data. user works data frame object called data analysisCode function. Examples given Get started page. analysisCode returns analysis output used later evaluating operating characteristics “Go / Go” decision. returned dataset referred “micro-evaluation” data. distinguishes results “Go / Go” evaluation referred “macro-evaluation” output. Micro-evaluation results used cases may wish drop doses interim analysis - decision drop doses can based output interval estimates. example may wish drop doses lower limit less zero (difference baseline comparison placebo). Micro-evaluation performed specified interim analysis. several interim analyses planned, Micro-evaluation performed whole dataset (without dropping doses), every interim. allows comparisons trial performance adapting adapting. macroCode summarises trial performance whole - provide single assessment success failure trial conclusion trial. example, may wish summarise proportion simulated trials showing maximal effect greater clinically meaningful effect. Similarly may wish show final estimates model parameters precise unbiased. Macro-evaluation summmarise trial performance level. analyzedata(...) function different generateData function fewer low level functions user typically want access. majority lower level functions analyzedata(...) govern data input output trial replicate data, general “housekeeping” submitting analysis jobs GRID.","code":""},{"path":[]},{"path":[]},{"path":"/articles/analyze_data.html","id":"optional-arguments","dir":"Articles","previous_headings":"Arguments","what":"Optional Arguments","title":"analyzeData","text":"running analyzedata(...) multi-processor machine analysis job split job roughly equal sized numbers replicates run across processors.","code":""},{"path":"/articles/generate_data.html","id":"how-it-works","dir":"Articles","previous_headings":"","what":"How it works","title":"generateData","text":"generateData function calls low level generate data components create sets simulated data. following components called create aspects simulated trial data: createTreatments(…): Creates dataset possible treatment regimes allocated subjects allocateTreatments(…): Allocates treatments subjects simulated study createCovariates(…): Creates set fixed covariates simulated population createParameters(…): Creates simulated fixed subject parameters subjects replicate createResponse(…): Creates simulated response variable based available derived data createMCAR(…): Adds simulated “missing” flag data createDropout(…): Adds simulated “missing” flag data based dropout function createInterims(…): Assigns subjects study interim analyses createDirectories(…): creates ReplicateData directory current working directory. writeData(…): writes simulation replicate data CSV generateData function iteratively builds combines data components replicate, stores data “ReplicateData” subdirectory working directory. data can analyzed using call analyzeData function.","code":""},{"path":"/articles/generate_data.html","id":"arguments","dir":"Articles","previous_headings":"","what":"Arguments","title":"generateData","text":"generateData function takes number arguments passed various lower level functions.","code":""},{"path":[]},{"path":[]},{"path":"/articles/simulation_overview.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Simulation Overview","text":"Williams Ette 2003 – ‘Determination model appropriateness’ “Simulation Designing Clinical Trials” pp74-103, Kimko Duffull eds, Marcel Dekker, NY Decision-Making Drug Development: Application Model Based Framework Assessing Trial Performance. Smith MK, French JL, Kowalski KG, Hutmacher MM, Ewy W. “Clinical Trial Simulation - applications trends” pp61-83, Kimko Peck eds, Springer, NY Quantitative Approach Making Go/-Go Decisions Drug Development. Chuang-Stein C, Kirby S, French JL, Kowalski KG, Marshall SF, Smith MK, Bycott P, Beltangady M.Therapeutic Innovation & Regulatory Science Vol 45, Issue 2, pp. 187 - 202 Modeling simulation support dose selection clinical development SC-75416, selective COX-2 inhibitor treatment acute chronic pain. Kowalski KG, Olson S, Remmers AE, Hutmacher MM. Clin Pharmacol Ther. 2008 Jun;83(6):857-66. Model-based drug development. Lalonde R, Kowalski K, Hutmacher M, Ewy W, Nichols D, Milligan P, et al. Clin Pharmacol Ther. 2007 Jul;82(1):21-32 Model-based drug development: rational approach efficiently accelerate drug development. Milligan PA, Brown MJ, Marchant B, Martin SW, van der Graaf PH, Benson N, Nucci G, Nichols DJ, Boyd RA, Mandema JW, Krishnaswami S, Zwillich S, Gruben D, Anziano RJ, Stock TC, Lalonde RL. Clin Pharmacol Ther. 2013 Jun;93(6):502-14. doi: 10.1038/clpt.2013.54.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Mike K Smith. Author, maintainer. Rich Pugh. Author. Roman Francois. Author. Francisco Gochez. Author. Jian Li. Contributor. Jinhao Luo. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smith M, Pugh R, Francois R, Gochez F (2022). MSToolkit: MSToolkit Library Clinical Trial Design. R package version 3.3.0, https://github.com/MikeKSmith/MSToolkit.","code":"@Manual{,   title = {MSToolkit: The MSToolkit Library For Clinical Trial Design},   author = {Mike K Smith and Rich Pugh and Roman Francois and Francisco Gochez},   year = {2022},   note = {R package version 3.3.0},   url = {https://github.com/MikeKSmith/MSToolkit}, }"},{"path":[]},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"The MSToolkit Library For Clinical Trial Design","text":"MSToolkit R package written help users simulate clinical trials, evaluate designs, analysis methodology quantify operating characteristics application dose study level decision criteria. Can simulate parallel group, crossover longitudinal designs. Flexibility defining data generation processes using parametric models. Data generation model parameters can vary across simulation replicates; parameters can vary subjects. data generation function specifies linear predictor mean response given inputs (dose, time, covariates); inverse link functions allow generation continuous, binary count data. User-written inverse link functions allow data generation variety distributions. Model parameters covariates subject / replicate can generated multivariate normal distributions sampled external data files e.g. existing data files.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"The MSToolkit Library For Clinical Trial Design","text":"best way install MSToolkit currently, install development version directly GitHub.","code":"#install.packages(\"devtools\") devtools::install_github(\"MikeKSmith/MSToolkit\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"The MSToolkit Library For Clinical Trial Design","text":"users start generateData() generates data controlls dropout missing data specifying design, allocation treatments, generation parameters, functional specification. function great number arguments control pass information low level functions. generateData function iteratively builds combines data components replicate, replicate datasets stored individual .CSV files (“replicate000x.csv”) “ReplicateData” subdirectory working directory. data generated, next step analyze replicate data using analyzeData(). function wraps together functions performing user-specified analysis replicate datasets also performing micro- macro- level summaries analysis results. summary files named “MicroSummary.csv” “MacroSummary.csv” respectively, stored current R working directory. Besides, two directories called “MicroEvaluation” “MacroEvaluation” created current R working directory output analysisCode (“Micro000x.csv”) macroCode (“Macro000x.csv”) functions respectively. Furthermore, analyzeData function can use parallel package split analysis across CPUs across cores compute resource running . Specifying grid = TRUE splits job across either (number cores - 1) getOption(\"max.clusters\") whichever minimum. set FALSE default.","code":"library(MSToolkit)  generateData(   replicateN = 500,    subjects = 400,    treatDoses = c(0, 5, 25, 50, 100),    conCovNames = c(\"wt\", \"age\"),    conCovMean = c(83, 55) ,    conCovVCov = c(14,10)^2 ,    conCovDigits = 1,    conCovCrit = \"18 <= age <= 65\",    genParNames = \"E0,ED50,EMAX\",    genParMean = c(2,50,10),    genParVCov = diag( c(.5,30,10) ),    genParBtwNames = \"E0,ED50,EMAX\",    genParBtwMean = c(0,0,0),    genParBtwVCov = diag(3),    respEqn = \"E0 + ((DOSE * EMAX)/(DOSE + ED50))\",     respVCov = 5,    interimSubj = \".3,.7\")  # This example generates 500 .CSV files with 400 subjects each to store the  # replicate datasets in the \"ReplicateData\" directory. # Standard analysis code emaxCode <- function(data){   library(DoseResponse)   with( data,      {     uniDoses <- sort( unique(DOSE))                                                                         eFit <- emaxalt( RESP, DOSE )     outDf <- data.frame( DOSE = uniDoses,        MEAN = eFit$dm[as.character(uniDoses)],        SE = eFit$dsd[as.character(uniDoses)] )     outDf$LOWER <- outDf$MEAN - 2 * outDf$SE     outDf$UPPER <- outDf$MEAN + 2 * outDf$SE     outDf$N     <- table(DOSE)[ as.character(uniDoses) ]     outDf    })  }               # Macro evaluation code macrocode <- function(data) {   # making up a t-test   mu0   <- data$MEAN[ data$DOSE == 0 & data$INTERIM == 0]   mu100 <- data$MEAN[ data$DOSE == 100 & data$INTERIM == 0]   n0    <- data$N[ data$DOSE == 0 & data$INTERIM == 0]   n100  <- data$N[ data$DOSE == 100 & data$INTERIM == 0]   sd0   <- data$SE[ data$DOSE == 0 & data$INTERIM == 0]   sd100 <- data$SE[ data$DOSE == 100 & data$INTERIM == 0]      sddiff <- if( n0 == n100 ){     sqrt( (sd0^2 + sd100^2)  / (n0 + n100) )   } else {     sqrt( (1/n0 + 1/n100) * ( (n0-1)*sd0^2 + (n100-1)*sd100^2  ) / (n0+n100-2)  )   }   tstat  <- ( mu100 - mu0 ) / sddiff    success <- abs(tstat) > qt( .975, n0+n100-2)      data.frame( SUCCESS = success, TSTAT = tstat ) }    # Interim analysis code interimCode <- function( data ){   dropdose  <- with( data, DOSE [ sign(UPPER) != sign(LOWER) & DOSE != 0] )   outList <- list()   if( length(dropdose) > 0 ) outList$DROP <- dropdose   outList$STOP <- length(dropdose) == nrow(data)-1   outList }     # Run analysis analyzeData( 1:5, analysisCode = emaxCode, macroCode = macrocode,    interimCode = interimCode )"},{"path":"/index.html","id":"store-the-simulation-results","dir":"","previous_headings":"","what":"Store the simulation results","title":"The MSToolkit Library For Clinical Trial Design","text":"default, MSToolkit writes Replicate, Micro- Maco-evaluation datasets CSV format files, one simulation replicate. written respective folders. benefit using CSV ability easily view simulated data analysis results replicate, well ability share others. However, clearly means three times many CSV files simulation replicates, may undesirable. also option write replicate data (simulated data) .RData files keep replicate data memory. Micro- macro-evaluation datasets always written CSV files.","code":"# retrieve MSToolkit Data Method getEctdDataMethod(method = 'CSV')     # change the MSToolkit Data Method setEctdDataMethod(method = 'CSV')   # or setEctdDataMethod(method = 'RData') # or setEctdDataMethod(method = 'Internal')"},{"path":"/index.html","id":"sas","dir":"","previous_headings":"","what":"SAS","title":"The MSToolkit Library For Clinical Trial Design","text":"using SAS analytical engine using external compute resource environment, important set preferences location R SAS executable (required). file ECTD.ini provided top directory library contain following rows:","code":"# Instructions to set up environmental variables  # This option allows the setting of the R execution binary on a Linux grid Sys.setenv(\"RLSF_LINUX\"=\".\")  # This option allows the setting of the SAS execution path on a Unix machine Sys.setenv(\"SASPATH_UNIX\"=\".\")  # This option allows the setting of the SAS execution path on a Windows machine Sys.setenv(\"SASPATH_WIN\"=\"C:\\\\Program Files\\\\SAS Institute\\\\SAS\\\\V8\\\\sas.exe\")"},{"path":"/reference/MSToolkit-package.html","id":null,"dir":"Reference","previous_headings":"","what":"MSToolkit: The MSToolkit Library For Clinical Trial Design — MSToolkit-package","title":"MSToolkit: The MSToolkit Library For Clinical Trial Design — MSToolkit-package","text":"Simulate data, analysis data assess operating characteristcs clinical trials.","code":""},{"path":[]},{"path":"/reference/MSToolkit-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"MSToolkit: The MSToolkit Library For Clinical Trial Design — MSToolkit-package","text":"Maintainer: Mike K Smith mstoolkit@gmail.com Authors: Rich Pugh rpugh@mango-solutions.com Roman Francois Francisco Gochez contributors: Jian Li [contributor] Jinhao Luo [contributor]","code":""},{"path":"/reference/addResidualError.html","id":null,"dir":"Reference","previous_headings":"","what":"Add residual error to the response. — addResidualError","title":"Add residual error to the response. — addResidualError","text":"Adds residual error generated response, based supplied variance values.","code":""},{"path":"/reference/addResidualError.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add residual error to the response. — addResidualError","text":"","code":"addResidualError(   response,   covariance,   errStruc = c(\"Additive\", \"Proportional\", \"Log-Normal\", \"Combined\"),   seed = .deriveFromMasterSeed() )"},{"path":"/reference/addResidualError.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add residual error to the response. — addResidualError","text":"response (Required) Numeric vector response data covariance (Required) Residual error (co)variance.  lower-triangle matrix, matrix . function parseCovMatrix used ensure matrix right format. errStruc (Optional) Function describing apply residual error: \"Additive\", \"Log-Normal\" \"Proportional\".  \"Additive\" default seed (Optional) Random seed use.  Derived current random seed default","code":""},{"path":"/reference/addResidualError.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add residual error to the response. — addResidualError","text":"numeric vector","code":""},{"path":"/reference/addResidualError.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add residual error to the response. — addResidualError","text":"first step algorithm set random number seed \"seed\" argument.  , number samples drawn multivariate normal distribution mean 0 variance set (parsed) covariance input.  number samples take set number elements \"response\" vector. Based \"errStruc\" input, algorithm continue follows.  * Additive, residual errors added response vector.  * Log Normal, response vector multiplied exponentiated residual error.  * Proportional, response vector multiplied \"1 + residual error\".","code":""},{"path":"/reference/addResidualError.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Add residual error to the response. — addResidualError","text":"earlier versions MSToolkit, \"Proportional\" Error Structure behaved differently (assumed parameters passed log scale). MSToolkit currently limit two residual error variances / covariances create additive, proportional combined additive + proportional error structures. time MSToolkit simulate time-series complex residual variance structures .e. multi-variate Normal distributions number error terms = number observations.","code":""},{"path":[]},{"path":"/reference/addResidualError.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add residual error to the response. — addResidualError","text":"Romain Francois, Rich Pugh","code":""},{"path":"/reference/addResidualError.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add residual error to the response. — addResidualError","text":"","code":"myVec <- 1:10   addResidualError(response = myVec, covariance = \"1\") #>             [,1] #>  [1,] -0.4696149 #>  [2,]  2.1967644 #>  [3,]  2.5382319 #>  [4,]  4.3917903 #>  [5,]  5.4404183 #>  [6,]  7.3023567 #>  [7,]  7.9701431 #>  [8,]  7.2786488 #>  [9,]  9.1239629 #> [10,]  7.6016181"},{"path":"/reference/allocateTreatments.html","id":null,"dir":"Reference","previous_headings":"","what":"Allocate treatment to subjects — allocateTreatments","title":"Allocate treatment to subjects — allocateTreatments","text":"Allocate component responsible allocating simulated subjects treatment group.","code":""},{"path":"/reference/allocateTreatments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Allocate treatment to subjects — allocateTreatments","text":"","code":"allocateTreatments(   trts,   subjects,   prop = NULL,   ordered = FALSE,   seed = .deriveFromMasterSeed(),   idCol = getEctdColName(\"Subject\"),   trtCol = getEctdColName(\"Trt\") )"},{"path":"/reference/allocateTreatments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Allocate treatment to subjects — allocateTreatments","text":"trts (Required) Maximum number treatments subjects can allocated.  Subjects allocated treatments \"1:trts\" subjects (Required) Number subjects allocated treatment group prop (Optional) Proportion subjects group.  default, equal proportions subjects assigned treatment arm ordered (Optional) treatments allocated order subject number (ie. first N subjects gets treatment 1) opposed random assignment.  Default FALSE (random assignment) seed (Optional) Random seed allocate interims.  Based current master seed default idCol (Optional) Subject variable name.  \"SUBJ\" default trtCol (Optional) Treatment variable name.  \"TRT\" default","code":""},{"path":"/reference/allocateTreatments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Allocate treatment to subjects — allocateTreatments","text":"data frame subjects treatment allocations.  data frame contain 2 variables: SUBJThe Subjects identifier TRTThe Treatment numeric subject allocated ...","code":""},{"path":"/reference/allocateTreatments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Allocate treatment to subjects — allocateTreatments","text":"Subjects numbered \"1\" \"sum(subjects)\" allocated single treatment treatment sequence.  possible treatments numbered \"1\" \"trts\". \"subjects\" single number, proportion argument used determine proportion allocated treatment.  default, subjects allocated randomly treatment group probability \"1/trts\". \"subjects\" vector length \"trts\", explicity defines number subjects allocate treatment group. \"ordered\" TRUE, allocation done order (eg. subject 1 gets treatment 1). can useful simulations quickly verify correct number proportion subjects allocated treatment. \"FALSE\", random allocation performed.","code":""},{"path":"/reference/allocateTreatments.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Allocate treatment to subjects — allocateTreatments","text":"Rich Pugh","code":""},{"path":"/reference/allocateTreatments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Allocate treatment to subjects — allocateTreatments","text":"","code":"# allocate 6 subjects randomly to 3 treatment groups   allocateTreatments(trts = 3, subjects = 6) #> Warning: Not all the treatments have been allocated #>   SUBJ TRT #> 1    1   1 #> 2    2   2 #> 3    3   2 #> 4    4   2 #> 5    5   2 #> 6    6   1    # allocate 6 subjects randomly to 3 treatment groups   #  and present in treatment order   allocateTreatments(trts = 3, subjects = 6, ordered = TRUE) #>   SUBJ TRT #> 1    1   1 #> 2    2   1 #> 3    3   2 #> 4    4   2 #> 5    5   3 #> 6    6   3    # allocate 2 subjects to group 1, 2 to group 2, 3 to group 3   # First two subjects will be allocated to TRT 1   allocateTreatments(trts = 3, subjects = c(2, 2, 3), ordered = TRUE) #>   SUBJ TRT #> 1    1   1 #> 2    2   1 #> 3    3   2 #> 4    4   2 #> 5    5   3 #> 6    6   3 #> 7    7   3    # allocation according to proportions   # 6 subjects to allocate in total in 2 groups   # 20% will be in group 1, 80% will be in group 2   allocateTreatments(trts = 2, subjects = 6, prop = c(0.2, 0.8)) #> Warning: Not all the treatments have been allocated #>   SUBJ TRT #> 1    1   2 #> 2    2   2 #> 3    3   2 #> 4    4   2 #> 5    5   2 #> 6    6   2    # allocation according to proportions   # 6 subjects to allocate in total in 2 groups   # 20% will be in group 1, 80% will be in group 2   # TRT 1 will be allocated first   allocateTreatments(trts = 2,                      subjects = 6,                      prop = c(0.2, 0.8),                      ordered = TRUE) #>   SUBJ TRT #> 1    1   1 #> 2    2   2 #> 3    3   2 #> 4    4   2 #> 5    5   2 #> 6    6   2"},{"path":"/reference/analyzeData.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze simulated data replicates — analyzeData","title":"Analyze simulated data replicates — analyzeData","text":"Analyzes set simulated trial data, possibly including interim analyses","code":""},{"path":"/reference/analyzeData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze simulated data replicates — analyzeData","text":"","code":"analyzeData(   replicates = \"*\",   analysisCode,   macroCode,   interimCode = NULL,   software = \"R\",   grid = FALSE,   waitAndCombine = TRUE,   cleanUp = FALSE,   removeMissing = TRUE,   removeParOmit = TRUE,   removeRespOmit = TRUE,   seed = .deriveFromMasterSeed(),   parOmitFlag = getEctdColName(\"ParOmit\"),   respOmitFlag = getEctdColName(\"RespOmit\"),   missingFlag = getEctdColName(\"Missing\"),   interimCol = getEctdColName(\"Interim\"),   doseCol = getEctdColName(\"Dose\"),   sleepTime = 15,   deleteCurrData = TRUE,   initialDoses = NULL,   stayDropped = TRUE,   fullAnalysis = TRUE,   workingPath = getwd(),   method = getEctdDataMethod() )"},{"path":"/reference/analyzeData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze simulated data replicates — analyzeData","text":"replicates (Optional) Vector replicates perform analysis: replicates analyzed default analysisCode (Required) File containing analysis code (R SAS) R function analysis (R ) macroCode (Required) R function used macro evaluation result datasets.  See help file macroEvaluation function information interimCode (Optional) R function applied interim datasets order creation interim decisions.  See help file interimAnalysis function information.  default, functions provided, resulting interim analyses performed software (Optional) software used analysis: either \"R\" \"SAS\".  \"R\" default software used grid (Optional) available, analysis split across available CPUs.  Uses \"parallel\" package split jobs across available cores.  Uses minimum either: Cores-1 getOption(\"max.clusters\"), usually =2. FALSE default. waitAndCombine (Optional) process wait analyses finish, combine micro macro summary files?  TRUE default cleanUp (Optional) micro/macro directories removed completion?  TRUE default removeMissing (Optional) rows marked 'Missing' data generation step removed data analysis performed? TRUE default removeParOmit (Optional) rows marked 'Omitted' parameter data generation step (ie. parameters range) removed data analysis performed?  TRUE default removeRespOmit (Optional) rows marked 'Omitted' response generation step (ie. responses range) removed data analysis performed?  TRUE default seed (Optional) Random number seed use analysis.  Based current random seed default parOmitFlag (Optional) Parameter omit flag name.  \"PAROMIT\" default respOmitFlag (Optional) Response omit flag name.  \"RESPOMIT\" default missingFlag (Optional) Missing flag name.  \"MISSING\" default interimCol (Optional) Interim variable name.  \"INTERIM\" default doseCol (Optional) Dose variable name.  \"DOSE\" default sleepTime (Optional) Number seconds sleep iterative checks grid job completion.  15 seconds used default deleteCurrData (Optional) existing micro evaluation macro evaluation data removed new analysis performed?  TRUE default initialDoses (Optional) interim analyses, doses present interim 1?  included default stayDropped (Optional) interim analyses, dose dropped, stay dropped following interims (opposed allowing interim step reopen dose) fullAnalysis (Optional) \"full\" analysis performed doses?  Default TRUE workingPath (Optional) Root directory replicate data stored, perform analysis.  Current working directory used default method Data storage method (ie. replicate data stored). Given getEctdDataMethod default","code":""},{"path":"/reference/analyzeData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze simulated data replicates — analyzeData","text":"function produce direct output.  consequence, however, many analysis, summary log files produced.","code":""},{"path":"/reference/analyzeData.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analyze simulated data replicates — analyzeData","text":"first task function check options specifed: * \"grid\" network unavailable length \"replicates\" input 1, \"grid\" flag set FALSE * \"grid\" flag TRUE, call analyzeData split across multiple processors using \"parallel\" library * length \"replicates\" vector 1, \"waitAndCombine\" flag set FALSE * \"waitAndCombine\" flag set FALSE, \"cleanUp\" flag also set FALSE analyzeData function iterate around replicate specified \"replicates\" vector.  replicate, function first call analyzeRep required inputs. output call analyzeRep data frame containing micro evaluation data.  data frame checked ensure correct format. return analyzeRep valid \"Micro Evaluation\" dataset, saved \"MicroEvaluation\" folder, also passed macroEvaluation function analysis. return macroEvaluation valid \"Macro Evaluation\" dataset, saved \"MicroEvaluation\" folder. \"waitAndCombine\" flag set TRUE, function wait grid jobs finished (grid used), compile \"Micro\" \"Macro\" evaluation results single summary files (using compileSummary function).","code":""},{"path":"/reference/analyzeData.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Analyze simulated data replicates — analyzeData","text":"restrictions code inputs analyzeData function.  restrictions discussed : Analysis Code: \"analysisCode\" input must either R function reference external file.  reference external file, must contain either SAS code (software \"SAS\") R code (software \"R\").  code R function, external R script, must accept data frame argument return acceptable \"Micro Evaluation\" data frame set checkMicroFormat.  code external SAS script, must accept use SAS dataset called \"work.infile\" create SAS dataset called \"work.outfile\" conforms \"Micro Evalutation\" format set checkMicroFormat.  information \"Micro Evaluation\" structures can found help file function checkMicroFormat. Interim Code: \"interimCode\" input must R function accepts single \"Micro Evaluation\" data input, returns R \"list\" structure either empty contains one following elements: element called \"STOP\" logical vector length 1.  tells analyzeData function whether analysis halted interim element called \"DROP\" vector numeric values relating doses data drop next interim analyzed. information \"Micro Evaluation\" structures can found help file function interimAnalysis. Macro Code: \"macroCode\" input must R function accepts enhanced \"Micro Evaluation\" data input, returns valid \"Macro Evaluation\" data structure (specified help file checkMacroFormat function.","code":""},{"path":[]},{"path":"/reference/analyzeData.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Analyze simulated data replicates — analyzeData","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/analyzeData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze simulated data replicates — analyzeData","text":"","code":"if (FALSE) {  # Standard analysis code emaxCode <- function(data){   library(DoseResponse)   with( data,     {     uniDoses <- sort( unique(DOSE))     eFit <- emaxalt( RESP, DOSE )     outDf <- data.frame( DOSE = uniDoses,       MEAN = eFit$dm[as.character(uniDoses)],       SE = eFit$dsd[as.character(uniDoses)] )     outDf$LOWER <- outDf$MEAN - 2 * outDf$SE     outDf$UPPER <- outDf$MEAN + 2 * outDf$SE     outDf$N     <- table(DOSE)[ as.character(uniDoses) ]     outDf   }) }  # Macro evaluation code macrocode <- function(data) {   # making up a t-test   mu0   <- data$MEAN[ data$DOSE == 0 & data$INTERIM == 0]   mu100 <- data$MEAN[ data$DOSE == 100 & data$INTERIM == 0]   n0    <- data$N[ data$DOSE == 0 & data$INTERIM == 0]   n100  <- data$N[ data$DOSE == 100 & data$INTERIM == 0]   sd0   <- data$SE[ data$DOSE == 0 & data$INTERIM == 0]   sd100 <- data$SE[ data$DOSE == 100 & data$INTERIM == 0]    sddiff <- if( n0 == n100 ){     sqrt( (sd0^2 + sd100^2)  / (n0 + n100) )   } else {     sqrt( (1/n0 + 1/n100) * ( (n0-1)*sd0^2 + (n100-1)*sd100^2  ) / (n0+n100-2)  )   }   tstat  <- ( mu100 - mu0 ) / sddiff   success <- abs(tstat) > qt( .975, n0+n100-2)    data.frame( SUCCESS = success, TSTAT = tstat ) }  # Interim analysis code interimCode <- function( data ){   dropdose  <- with( data, DOSE [ sign(UPPER) != sign(LOWER) & DOSE != 0] )   outList <- list()   if( length(dropdose) > 0 ) outList$DROP <- dropdose   outList$STOP <- length(dropdose) == nrow(data)-1   outList }  # Run analysis analyzeData( 1:5, analysisCode = emaxCode, macroCode = macrocode,   interimCode = interimCode )  }"},{"path":"/reference/analyzeRep.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyse a single replicate of data — analyzeRep","title":"Analyse a single replicate of data — analyzeRep","text":"analyzeRep function analyzes single replicate data, possibly different interim levels.","code":""},{"path":"/reference/analyzeRep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyse a single replicate of data — analyzeRep","text":"","code":"analyzeRep(   analysisCode,   replicate,   removeMissing = TRUE,   removeParOmit = TRUE,   removeRespOmit = TRUE,   interimCode = NULL,   software = c(\"R\", \"SAS\"),   seed = .deriveFromMasterSeed(),   parOmitFlag = getEctdColName(\"ParOmit\"),   respOmitFlag = getEctdColName(\"RespOmit\"),   missingFlag = getEctdColName(\"Missing\"),   interimCol = getEctdColName(\"Interim\"),   doseCol = getEctdColName(\"Dose\"),   initialDoses = NULL,   stayDropped = TRUE,   fullAnalysis = TRUE,   workingPath = getwd(),   method = getEctdDataMethod() )"},{"path":"/reference/analyzeRep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyse a single replicate of data — analyzeRep","text":"analysisCode (Required) File containing analysis code (R SAS) R function analysis (R ) replicate (Required) Replicate number data analyzed removeMissing (Optional) rows marked 'Missing' data generation step removed data analysis performed? TRUE default removeParOmit (Optional) rows marked 'Omitted' parameter data generation step (ie. parameters range) removed data analysis performed?  TRUE default removeRespOmit (Optional) rows marked 'Omitted' response generation step (ie. responses range) removed data analysis performed?  TRUE default interimCode (Optional) R function applied interim datasets order creation interim decisions.  See help file interimAnalysis function information.  default, functions provided, resulting interim analyses performed software (Optional) software used analysis: either \"R\" \"SAS\".  \"R\" default software used seed (Optional) Random number seed use analysis.  Based current random seed default parOmitFlag (Optional) Parameter omit flag name.  \"PAROMIT\" default respOmitFlag (Optional) Response omit flag name.  \"RESPOMIT\" default missingFlag (Optional) Missing flag name.  \"MISSING\" default interimCol (Optional) Interim variable name.  \"INTERIM\" default doseCol (Optional) Dose variable name.  \"DOSE\" default initialDoses (Optional) interim analyses, doses present interim 1?  included default stayDropped (Optional) interim analyses, dose dropped, stay dropped following interims (opposed allowing interim step reopen dose) fullAnalysis (Optional) \"full\" analysis performed doses?  Default TRUE workingPath (Optional) Root directory replicate data stored, perform analysis.  Current working directory used default method Data storage method (ie. replicate data stored). Given getEctdDataMethod default","code":""},{"path":"/reference/analyzeRep.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyse a single replicate of data — analyzeRep","text":"\"Micro Evaluation\" structure additional variables (interim column, drop flag stop flag)","code":""},{"path":"/reference/analyzeRep.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analyse a single replicate of data — analyzeRep","text":"analyzeRep function calls performAnalysis function order analyze summarize single simulated replicate dataset (held \"ReplicateData\" subdirectory specified working path). first step analysis use removeMissing, removeParOmit removeRespOmit flags (together missingFlag, parOmitFlag respOmitFlag inputs) order subset data required.  example, may wish remove observations flagged \"missing\" earlier simulation subject dropout.  subset applied data analysis. analysis code must either R function, reference external R script, reference external SAS script.  software set \"SAS\", assumed analysisCode external SAS script.  analysis code SAS script, must accept single dataset called work.infile, create output dataset called work.outfile.  work.outfile dataset must valid \"Micro Evaluation\" structure specified help file checkMicroFormat.  software \"R\", analysis code input must either R function R script.  R analysis code must also return valid \"Micro Evaluatoin\" structure specified function checkMicroFormat first step analyzeRep perform full analysis data (possibly subset remove* inputs).  Following analysis, checkMicroFormat function used ensure return data valid \"Micro Evaluation\" data structure.  return structure appended drop stop flags (set 0) interim variables (interim \"FULL\"). interimCode specified, \"interimCol\" variable found data, interim analyses performed iteratively sections data.  interimCode input must R function returns suitable list structure described interimAnalysis help file.  value \"interimCol\", analysis performed section data (using call performAnalysis), return analysis checked (using call checkMicroFormat).  \"Micro Evaluation\" output passed interimAnalysis function return list checked instruction.  return interim list includes doses \"DROP\", doses removed future analyses.  \"STOP\" flag list set \"TRUE\", analysis stopped interim. Finally, micro evaluation outputs (appended interim variables drop/stop flags) combined returned.","code":""},{"path":[]},{"path":"/reference/analyzeRep.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Analyse a single replicate of data — analyzeRep","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/analyzeRep.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyse a single replicate of data — analyzeRep","text":"","code":"if (FALSE) {   # Analysis Code   emaxFun <- function(data){     library(DoseResponse)     with( data,      {       uniDoses <- sort( unique(D))       eFit <- emaxalt( RESP, D )       outDf <- data.frame( D = uniDoses,       MEAN = eFit$dm[as.character(uniDoses)],       SE = eFit$dsd[as.character(uniDoses)] )       outDf$LOWER <- outDf$MEAN - 2 * outDf$SE       outDf$UPPER <- outDf$MEAN + 2 * outDf$SE       outDf$N     <- table(DOSE)[ as.character(uniDoses) ]       outDf      })    }    analyzeRep(replicate = 1, analysisCode = emaxFun) }"},{"path":"/reference/applyPredCode.html","id":null,"dir":"Reference","previous_headings":"","what":"Parses and applys NONMEM statements — applyPredCode","title":"Parses and applys NONMEM statements — applyPredCode","text":"Parses NONMEM statements attempts apply data frame order create response variable","code":""},{"path":"/reference/applyPredCode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parses and applys NONMEM statements — applyPredCode","text":"","code":"applyPredCode(   df,   pred,   respCol = getEctdColName(\"Response\"),   report = TRUE,   keepCols = respCol,   verbose = getEctdVerbose() )  parsePredCode(model, respCol = getEctdColName(\"Response\"))"},{"path":"/reference/applyPredCode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parses and applys NONMEM statements — applyPredCode","text":"df (Required) Data frame parsed NONMEM statements applied pred Character vector NONMEM statements respCol Response column name ( iven getEctdColName default) report Logical: textual report produced? keepCols Character vector column names retain return dataset verbose Logical: verbose logging used? ( given getEctdVerbose default) model File containing analysis code (R SAS) R function analysis (R )","code":""},{"path":"/reference/applyPredCode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parses and applys NONMEM statements — applyPredCode","text":"dataset new columns added","code":""},{"path":"/reference/applyPredCode.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parses and applys NONMEM statements — applyPredCode","text":"applyPredCode function calls parsePredCode function order convert NONMEM statements executable R statements.  applyPredCode function iteratively \"tries\" apply statements data (\"df\"), producing textual report process \"report\" set TRUE.  \"keepCols\" columns updated dataset returned","code":""},{"path":"/reference/applyPredCode.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parses and applys NONMEM statements — applyPredCode","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/applyPredCode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parses and applys NONMEM statements — applyPredCode","text":"","code":"parsePredCode(c(   \"X = 1\",   \"IF (X.EQ.1.OR.Y.GT.0) STUD = 1\",    \"NEWVAR = THETA(1) + EXP(ETA(2))**LOG(EPS(1))\" )) #> Error in parsePredCode(c(\"X = 1\", \"IF (X.EQ.1.OR.Y.GT.0) STUD = 1\", \"NEWVAR = THETA(1) + EXP(ETA(2))**LOG(EPS(1))\")): could not find function \"parsePredCode\""},{"path":"/reference/calculateDiffsFromBase.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate differences from baseline — calculateDiffsFromBase","title":"Calculate differences from baseline — calculateDiffsFromBase","text":"Calculate responses differences baseline subject","code":""},{"path":"/reference/calculateDiffsFromBase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate differences from baseline — calculateDiffsFromBase","text":"","code":"calculateDiffsFromBase(   data,   respCol = getEctdColName(\"Response\"),   idCol = getEctdColName(\"Subject\"),   timeCol = getEctdColName(\"Time\"),   replicateCol = getEctdColName(\"Replicate\"),   baseDef = paste(timeCol, \"<= 0\"),   tolerance = 1e-05,   removeBaseline = TRUE )"},{"path":"/reference/calculateDiffsFromBase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate differences from baseline — calculateDiffsFromBase","text":"data Data frame respCol Response column names (given getEctdColName default) idCol Subject column names (given getEctdColName default) timeCol Time column names (given getEctdColName default) replicateCol Replicate column names (given getEctdColName default) baseDef Defintion \"baseline data\" subject (default \"Time <= 0\") tolerance eventual response values whose absolute removeBaseline Logical: remove baseline data \"differences baseline\" calculated?","code":""},{"path":"/reference/calculateDiffsFromBase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate differences from baseline — calculateDiffsFromBase","text":"data frame, responses subjects baseline response subtracted","code":""},{"path":"/reference/calculateDiffsFromBase.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate differences from baseline — calculateDiffsFromBase","text":"inputs checked, function ensures respCol, idCol timeCol variables dataset (data).  baseDef code applied data order create logical vector highlighting observations classed \"baseline\" values. subjects \"baseline\" data, warning generated original data returned. subject, baseline response calculated mean response within baseline period identified.  Within subject, baseline response subtracted response value.  removeBaseline TRUE, baseline data removed dataset","code":""},{"path":"/reference/calculateDiffsFromBase.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate differences from baseline — calculateDiffsFromBase","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/calculateObsSummary.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Observed Data Summary — calculateObsSummary","title":"Calculate Observed Data Summary — calculateObsSummary","text":"Calculate summary \"observed\" dataset (typically used overlay observed data simulated plot table)","code":""},{"path":"/reference/calculateObsSummary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Observed Data Summary — calculateObsSummary","text":"","code":"calculateObsSummary(   data,   respCol = getEctdColName(\"Response\"),   bVar = NULL,   subset = NULL,   alpha = 95,   digits = 3,   diffBase = FALSE,   doseCol = getEctdColName(\"Dose\"),   timeCol = getEctdColName(\"Time\"),   idCol = getEctdColName(\"Subject\"),   respType = c(\"Continuous\", \"Categorical\"),   catType = c(\"Count\", \"Proportion\"),   fillRespRange = TRUE )"},{"path":"/reference/calculateObsSummary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Observed Data Summary — calculateObsSummary","text":"data Observed data frame respCol Response column names (given getEctdColName default) bVar Variables summary produced (none default) subset Subsets applied observed data calculating summary alpha Alpha value calculation lower upper intervals digits Number digits round summary data diffBase Logical: differences baseline summarised instead raw data? doseCol Dose column names (given getEctdColName default) timeCol Time column names (given getEctdColName default) idCol Subject column names (given getEctdColName default) respType Response type: Continuous (default) Categorical catType Categorical response, \"Count\" (default) \"Proportion\" summary returned? fillRespRange Categorical response, \"fill\" range responses (see )","code":""},{"path":"/reference/calculateObsSummary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Observed Data Summary — calculateObsSummary","text":"data frame response summaries","code":""},{"path":"/reference/calculateObsSummary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Observed Data Summary — calculateObsSummary","text":"inputs checked, alpha value parsed using checkSimAlpha Subsets applied data \"subset\" specified differences baseline calculated using calculateDiffsFromBase required respType \"Continuous\": * Mean responses calculated Subject (idCol), Dose (doseCol), Time (timeCol), variables ((bVar) * following summaries created (based variables (bVar)) - Mean - Median - Minimum - Maximum - Number non-missing values - Lower alpha% percent interval - Upper alpha% percent interval dealing categorical responses, possible unique set responses (say): 1, 2, 4, 5 case, unclear whether value \"3\" included summary.  \"fillRespRange\" TRUE, included (although count/proportion zero) Frequencies calculated \"Response level\" (respCol) variables Frequences converted proportions (within variable level) required (catType)","code":""},{"path":"/reference/calculateObsSummary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate Observed Data Summary — calculateObsSummary","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/calculateSimTrialMeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Simulated Trial Means — calculateSimTrialMeans","title":"Calculate Simulated Trial Means — calculateSimTrialMeans","text":"Calculate mean simulated responses replicate","code":""},{"path":"/reference/calculateSimTrialMeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Simulated Trial Means — calculateSimTrialMeans","text":"","code":"calculateSimTrialMeans(   data,   respCol = getEctdColName(\"Response\"),   bVar = doseCol,   subset = NULL,   diffBase = FALSE,   idCol = getEctdColName(\"Subject\"),   timeCol = getEctdColName(\"Time\"),   doseCol = getEctdColName(\"Dose\"),   replicateCol = getEctdColName(\"Replicate\"),   respType = c(\"Continuous\", \"Categorical\"),   catType = c(\"Proportion\", \"Count\"),   fillRespRange = TRUE,   digits = 3 )"},{"path":"/reference/calculateSimTrialMeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Simulated Trial Means — calculateSimTrialMeans","text":"data Simulated trial data frame respCol Response column names (given getEctdColName default) bVar Variables means produced (\"Dose\" default) subset Subsets applied data calculating means diffBase Logical: differences baseline summarised instead raw data? idCol Subject column names (given getEctdColName default) timeCol Time column names (given getEctdColName default) doseCol Dose column names (given getEctdColName default) replicateCol Replicate column names (given getEctdColName default) respType Response type: Continuous (default) Categorical catType Categorical response, \"Count\" (default) \"Proportion\" summary returned? fillRespRange Categorical response, \"fill\" range responses (see ) digits Number digits round summary data","code":""},{"path":"/reference/calculateSimTrialMeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Simulated Trial Means — calculateSimTrialMeans","text":"data frame trial \"means\"","code":""},{"path":"/reference/calculateSimTrialMeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Simulated Trial Means — calculateSimTrialMeans","text":"inputs checked, alpha value parsed using checkSimAlpha Subsets applied data \"subset\" specified differences baseline calculated using calculateDiffsFromBase required respType \"Continuous\": * Mean responses calculated Replicate (replicateCol), Subject (idCol), Dose (doseCol), Time (timeCol), variables (bVar) * Means means calculated Replicate (replicateCol) variables (bVar) * data rounded (digits) returned dealing categorical responses, possible unique set responses (say): 1, 2, 4, 5 case, unclear whether value \"3\" included summary.  \"fillRespRange\" TRUE, included (although count/proportion zero) Frequencies calculated \"Response level\" (respCol) variables Frequences converted proportions (within variable level) required (catType)","code":""},{"path":"/reference/calculateSimTrialMeans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate Simulated Trial Means — calculateSimTrialMeans","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/checkColNames.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that column names are found in a data frame — checkColNames","title":"Check that column names are found in a data frame — checkColNames","text":"Checks column names specified \"cols\" found data frame names (given \"dNames\") produces neat error message ","code":""},{"path":"/reference/checkColNames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that column names are found in a data frame — checkColNames","text":"","code":"checkColNames(dNames, cols)"},{"path":"/reference/checkColNames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that column names are found in a data frame — checkColNames","text":"dNames Character vector column names data frame cols Character vector column names found data frame","code":""},{"path":"/reference/checkColNames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that column names are found in a data frame — checkColNames","text":"TRUE value (\"cols\" found \"dNames\") exception ","code":""},{"path":"/reference/checkColNames.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check that column names are found in a data frame — checkColNames","text":"Romain Francois","code":""},{"path":"/reference/checkColNames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that column names are found in a data frame — checkColNames","text":"","code":"checkColNames(LETTERS, \"D\") #> [1] TRUE   checkColNames(LETTERS, LETTERS[1:5]) #> [1] TRUE   if (FALSE) {     # Will show an error because \"Hello\" is not in LETTERS     checkColNames(LETTERS, c(\"A\", \"Hello\"))   }"},{"path":"/reference/checkDropOutFun.html","id":null,"dir":"Reference","previous_headings":"","what":"check the user supplied drop out function — checkDropOutFun","title":"check the user supplied drop out function — checkDropOutFun","text":"function performs checks ensire user-supplied dropout function correct.","code":""},{"path":"/reference/checkDropOutFun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check the user supplied drop out function — checkDropOutFun","text":"","code":"checkDropOutFun(fun, data, sizeSubset = 5, useSubset = TRUE, ...)"},{"path":"/reference/checkDropOutFun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"check the user supplied drop out function — checkDropOutFun","text":"fun (Required) Function check validity data (Required) Dataset use performing valildity check sizeSubset (Optional) Number \"initial\" rows provided data use test validity function.  default \"5\" useSubset (Optional) check operate subset data, opposed entire dataset?  TRUE default ... (Optional) Extra arguments passed directly function tested.  extra arguments passed default","code":""},{"path":"/reference/checkDropOutFun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"check the user supplied drop out function — checkDropOutFun","text":"Nothing. Function used sied effect generating error function correct.","code":""},{"path":"/reference/checkDropOutFun.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"check the user supplied drop out function — checkDropOutFun","text":"correct dropout function must least data argument, must return numeric vector containing values 0 1 length number rows dataset given.","code":""},{"path":"/reference/checkDropOutFun.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"check the user supplied drop out function — checkDropOutFun","text":"useSubset set TRUE, subset data used perform check. size subset minimum sizeSubset number rows dataset.","code":""},{"path":[]},{"path":"/reference/checkDropOutFun.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"check the user supplied drop out function — checkDropOutFun","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/checkDropOutFun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"check the user supplied drop out function — checkDropOutFun","text":"","code":"dFun <- function(data, prop) sample(0:1, nrow(data), TRUE, c(1-prop, prop))    testData <- data.frame(      SUBJ=rep(1:10, each=5),      TIME=rep(0:4, 10),      VALUE=rnorm(50))   checkDropOutFun( dFun, testData, prop = .2 )    if (FALSE) {     # wrong function     checkDropOutFun( max, testData )      # function that does not exist     checkDropOutFun( \"XXXX\", testData )      # function that does not exist     checkDropOutFun( XXXX, testData )    }"},{"path":"/reference/checkMacroFormat.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the macro format dataset — checkMacroFormat","title":"Check the macro format dataset — checkMacroFormat","text":"function used perform checks structure macro format dataset produced user-supplied macro code ","code":""},{"path":"/reference/checkMacroFormat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the macro format dataset — checkMacroFormat","text":"","code":"checkMacroFormat(data)"},{"path":"/reference/checkMacroFormat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the macro format dataset — checkMacroFormat","text":"data (Required) Dataset checked ensure valid \"Macro Evaluation\" structure","code":""},{"path":"/reference/checkMacroFormat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the macro format dataset — checkMacroFormat","text":"Nothing. used error generation side effects.","code":""},{"path":"/reference/checkMacroFormat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check the macro format dataset — checkMacroFormat","text":": Francisco Gochez, Rich Pugh","code":""},{"path":"/reference/checkMacroFormat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check the macro format dataset — checkMacroFormat","text":"","code":"checkMacroFormat(iris[1,])    if (FALSE) {     # not a data frame     checkMacroFormat( 1:10 )      # more than one row     checkMacroFormat(iris[1:2,])    }"},{"path":"/reference/checkMicroFormat.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that an input data structure is a valid ","title":"Check that an input data structure is a valid ","text":"checkMicroFormat checks given data frame meets certain criteria returns either modified version data frame \"empty\" micro evaluation frame given dose data column names. See details section information.","code":""},{"path":"/reference/checkMicroFormat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that an input data structure is a valid ","text":"","code":"checkMicroFormat(data, doseCol = getEctdColName(\"Dose\"), mustHaveDose = FALSE)"},{"path":"/reference/checkMicroFormat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that an input data structure is a valid ","text":"data (Required) data frame check validity doseCol (Optional) \"Dose\" variable name within supplied data. \"DOSE\" default mustHaveDose (Optional) \"doseCol\" variable necessarily present?  Default FALSE","code":""},{"path":"/reference/checkMicroFormat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that an input data structure is a valid ","text":"data frame described ","code":""},{"path":"/reference/checkMicroFormat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check that an input data structure is a valid ","text":"checkMicroFormat perform series basic checks data. checks valid structure follows: (1) data data frame (2) data least 1 row (3) \"mustHaveDose\" TRUE, data contains \"Dose\" column (given doseCol) fail stop return NULL structure","code":""},{"path":[]},{"path":"/reference/checkMicroFormat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check that an input data structure is a valid ","text":"Francisco Gochez","code":""},{"path":"/reference/checkMicroFormat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that an input data structure is a valid ","text":"","code":"checkMicroFormat(data = data.frame(DOSE = 1:4),   doseCol = \"DOSE\",   mustHaveDose = TRUE) #>   DOSE #> 1    1 #> 2    2 #> 3    3 #> 4    4"},{"path":"/reference/checkSimAlpha.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse alpha value — checkSimAlpha","title":"Parse alpha value — checkSimAlpha","text":"Parses input alpha value used numeric summary calculations","code":""},{"path":"/reference/checkSimAlpha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse alpha value — checkSimAlpha","text":"","code":"checkSimAlpha(alpha = 95)"},{"path":"/reference/checkSimAlpha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse alpha value — checkSimAlpha","text":"alpha Alpha value parsed","code":""},{"path":"/reference/checkSimAlpha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse alpha value — checkSimAlpha","text":"single numeric .5 1","code":""},{"path":"/reference/checkSimAlpha.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse alpha value — checkSimAlpha","text":"function first checks 1 input.  character, alpha parsed converted single numeric. alpha greater 1, assumed [1,100] scale, scaled onto [0,1] scale alpha less 0.5, assumed tbe [0,.5] scale (ie. .05 instead .95) converted [.5, 1] scale","code":""},{"path":"/reference/checkSimAlpha.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parse alpha value — checkSimAlpha","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/checkSimAlpha.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse alpha value — checkSimAlpha","text":"","code":"checkSimAlpha(\"95%\") #> [1] 0.95   checkSimAlpha(95) #> [1] 0.95   checkSimAlpha(5) #> [1] 0.95"},{"path":"/reference/checkSymmetricPDMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks if a matrix is symmetric and positive definite — checkSymmetricPDMatrix","title":"Checks if a matrix is symmetric and positive definite — checkSymmetricPDMatrix","text":"Checks matrix symmetric positive definite using eigen value decomposition.","code":""},{"path":"/reference/checkSymmetricPDMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks if a matrix is symmetric and positive definite — checkSymmetricPDMatrix","text":"","code":"checkSymmetricPDMatrix(mat, tol = 1e-06)"},{"path":"/reference/checkSymmetricPDMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checks if a matrix is symmetric and positive definite — checkSymmetricPDMatrix","text":"mat (Required) matrix check tol (Optional) tolorence use comparing value 0. default \"1e-06\"","code":""},{"path":"/reference/checkSymmetricPDMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks if a matrix is symmetric and positive definite — checkSymmetricPDMatrix","text":"Returns error matrix satisfy symmetric positive definite. Otherwise return anything","code":""},{"path":"/reference/checkSymmetricPDMatrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Checks if a matrix is symmetric and positive definite — checkSymmetricPDMatrix","text":"Romain Francois","code":""},{"path":"/reference/checkSymmetricPDMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Checks if a matrix is symmetric and positive definite — checkSymmetricPDMatrix","text":"","code":"checkSymmetricPDMatrix( diag(4))   A <- matrix( c( 2, -1, 0, -1, 2, -1, 0, -1, 2 ), nrow=3, byrow=TRUE )   checkSymmetricPDMatrix( A )   if (FALSE) {   # Not symmetric   B <- matrix( c( 1, 2, 3, 4, 5, 6, 7, 8, 9), nrow=3, byrow=TRUE )   checkSymmetricPDMatrix(B)   # Not positive definite   C <- matrix( c( -2, 1, 0, 1, -2, 1, 0, 1, -2 ), nrow=3, byrow=TRUE )   checkSymmetricPDMatrix(C)   }"},{"path":"/reference/compileSummary.html","id":null,"dir":"Reference","previous_headings":"","what":"Compile all Micro or Macro evaluation data — compileSummary","title":"Compile all Micro or Macro evaluation data — compileSummary","text":"function reads micro evaluation macro evaluation data amalgamates single data frame additional column indicating replicate row belongs .  data frame written \"m[ia]croSummary.csv\".","code":""},{"path":"/reference/compileSummary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compile all Micro or Macro evaluation data — compileSummary","text":"","code":"compileSummary(   dataType = c(\"MicroEvaluation\", \"MacroEvaluation\"),   replicates = NULL,   prefix = switch(dataType, MicroEvaluation = \"micro\", MacroEvaluation = \"macro\"),   replicateCol = getEctdColName(\"Replicate\"),   workingPath = getwd() )"},{"path":"/reference/compileSummary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compile all Micro or Macro evaluation data — compileSummary","text":"dataType (Optional) string indicates two data types read. Must either \"MicroEvaluation\" \"MacroEvaluation\". Partial matching used .  See match.arg.  Default \"MicroEvaluation\" replicates (Optional) replicates compiled. default, function compile available replicate data time prefix Prefix use searching files compile replicateCol Replicate column name (given getEctdColName default) workingPath (Optional) working directory used root \"Micro\" \"Macro\" evaluation directories.  Also directory compiled summary files created.  current working directory used default","code":""},{"path":"/reference/compileSummary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compile all Micro or Macro evaluation data — compileSummary","text":"CompileSummary return value.","code":""},{"path":"/reference/compileSummary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compile all Micro or Macro evaluation data — compileSummary","text":"Builds path existing Micro Macro file compiled.  Reads data text, paste Replicate column name text section imported.  Write \"full\" dataset compilated seperate datasets found","code":""},{"path":"/reference/compileSummary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compile all Micro or Macro evaluation data — compileSummary","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/compileSummary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compile all Micro or Macro evaluation data — compileSummary","text":"","code":"if (FALSE) {     # a directory MicroEvaluation need to be there and be full     # of files matching the pattern micro[0-9]{4}.csv     compileSummary(dataType = \"Micro\")      # a directory MacroEvaluation need to be there and be full     # of files matching the pattern macro[0-9]{4}.csv     compileSummary(dataType = \"Macro\")    }"},{"path":"/reference/convertSASIncludeRows.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a SAS 'IF' statement — convertSASIncludeRows","title":"Create a SAS 'IF' statement — convertSASIncludeRows","text":"Create SAS '' statement, used describe rows include SAS analysis","code":""},{"path":"/reference/convertSASIncludeRows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a SAS 'IF' statement — convertSASIncludeRows","text":"","code":"convertSASIncludeRows(   includeRows = NULL,   doseCol = getEctdColName(\"Dose\"),   interimCol = getEctdColName(\"Interim\") )"},{"path":"/reference/convertSASIncludeRows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a SAS 'IF' statement — convertSASIncludeRows","text":"includeRows Row inclusion matrix (2 columns: Interim value Dose value) doseCol Dose column name, given getEctdColName default interimCol Interim column name, given getEctdColName default","code":""},{"path":"/reference/convertSASIncludeRows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a SAS 'IF' statement — convertSASIncludeRows","text":"single character string","code":""},{"path":"/reference/convertSASIncludeRows.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a SAS 'IF' statement — convertSASIncludeRows","text":"Takes matrix interim dose values, produces \"SAS style\" statement","code":""},{"path":"/reference/convertSASIncludeRows.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a SAS 'IF' statement — convertSASIncludeRows","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/convertSASIncludeRows.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a SAS 'IF' statement — convertSASIncludeRows","text":"","code":"convertSASIncludeRows( cbind(rep(1:2, each = 3), c(0, 15, 30, 0, 30, 45) ) ) #> [1] \"IF (INTERIM = 1 and DOSE = 0) or (INTERIM = 1 and DOSE = 15) or (INTERIM = 1 and DOSE = 30) or (INTERIM = 2 and DOSE = 0) or (INTERIM = 2 and DOSE = 30) or (INTERIM = 2 and DOSE = 45);\""},{"path":"/reference/convertToSASCode.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert R to SAS Statements — convertToSASCode","title":"Convert R to SAS Statements — convertToSASCode","text":"Converts R statements SAS statements, included batch call SAS system","code":""},{"path":"/reference/convertToSASCode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert R to SAS Statements — convertToSASCode","text":"","code":"convertToSASCode(code)"},{"path":"/reference/convertToSASCode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert R to SAS Statements — convertToSASCode","text":"code (Required) R code elements converted SAS statements","code":""},{"path":"/reference/convertToSASCode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert R to SAS Statements — convertToSASCode","text":"single character string representing \"SAS\" version input code","code":""},{"path":"/reference/convertToSASCode.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert R to SAS Statements — convertToSASCode","text":"function accept either character vector character matrix 3 columns. input vector, function assumes logical statements converted SAS code.  converted statements prefixed \"\" statement collapsed based semi- colons. input 3 column vector, function convert first column (logical) statments SAS code, prefix \"\" statement.  2nd column pasted together first column, seperated \"\" statement.  3rd column pasted together third column seperated \"=\" sign.  whole string collapsed based \";\" symbols returned.","code":""},{"path":"/reference/convertToSASCode.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert R to SAS Statements — convertToSASCode","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/convertToSASCode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert R to SAS Statements — convertToSASCode","text":"","code":"if (FALSE) {  convertToSASCode(c(\"X > 1\", \"X < 0\", \"Y > 0 & Y < 10\")) #  [1] \"IF X > 1 ;IF X < 0 ;IF Y > 0 AND Y < 10 ;\"  sasMat <- cbind(c(\"X > 1\", \"X < 0\", \"Y > 0 & Y < 10\"), c(\"Col1\", \"Col2\", \"Col3\"), 1:3) sasMat #     [,1]             [,2]   [,3] #[1,] \"X > 1\"          \"Col1\" \"1\" #[2,] \"X < 0\"          \"Col2\" \"2\" #[3,] \"Y > 0 & Y < 10\" \"Col3\" \"3\" convertToSASCode(sasMat)   # Convert matrix of \"data change\" code # [1] \"IF X > 1 THEN Col1 = 1 ;IF X < 0 THEN Col2 = 2 ;IF Y > 0 AND Y < 10 THEN Col3 = 3 ;\"  }"},{"path":"/reference/createContinuousCovariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a set of continuous covariates — createContinuousCovariates","title":"Create a set of continuous covariates — createContinuousCovariates","text":"Creates set continuous covariates multivariate normal distribution (optionally) set constraints.","code":""},{"path":"/reference/createContinuousCovariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a set of continuous covariates — createContinuousCovariates","text":"","code":"createContinuousCovariates(   subjects,   names,   mean,   covariance = 1,   range = NULL,   digits,   maxDraws = 100,   seed = .deriveFromMasterSeed(),   idCol = getEctdColName(\"Subject\"),   includeIDCol = TRUE )"},{"path":"/reference/createContinuousCovariates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a set of continuous covariates — createContinuousCovariates","text":"subjects (Required) Subjects create covariates names (Required) Names continuous covariates.  valid R names (See validNames) duplicate name given mean (Required) Vector means. Must length names covariance (Optional) Lower triangle covariance matrix. See parseCovMatrix details.  1 default range (Optional) Ranges acceptable values covariates. See parseRangeCode details.  missing default, resulting \"range\" limitation applied digits (Optional) Number digits used round values.  argument can either missing (default), rounding done, length one variables rounded digits, length number covariates covariate rounded according value. argument first parsed parseCharInput can either character vector numeric vector.  See parseCharInput.  parsed digits vector length one length equal number covariates, error generated ectdStop function.  missing default, resulting rounding performed maxDraws (Optional) Maximum number attempts allowed initial data range (100 default) seed (Optional) Random seed use.  default, derived master random seed idCol (Optional) Name subject column. Must valid R name (See validNames) equal one entry names. \"SUBJ\" default includeIDCol (Optional) subject column included.","code":""},{"path":[]},{"path":"/reference/createContinuousCovariates.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a set of continuous covariates — createContinuousCovariates","text":"Romain Francois","code":""},{"path":"/reference/createContinuousCovariates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a set of continuous covariates — createContinuousCovariates","text":"","code":"# 30 samples from a :      [ 0 ]   [ 1, 0, 0 ]   #                      N ( [ 0 ] , [ 0, 1, 0 ] )   #                          [ 1 ]   [ 0, 0, 1 ]   dat <- createContinuousCovariates( 30,                                      mean = \"0,0,1\",                                      names = c(\"X\", \"Y\", \"Z\")  )     # 30 samples from a :      [ 0 ]   [ 1, 0, 0 ]   #                      N ( [ 0 ] , [ 0, 1, 0 ] )   #                          [ 1 ]   [ 0, 0, 1 ]   # truncated at X > 0   dat <- createContinuousCovariates( 30,                                      mean = \"0,0,1\",                                      names = c(\"X\", \"Y\", \"Z\"),      range= \"X > 0\"  )    # 30 samples from a :      [ 0 ]   [ 1, 0, 0 ]   #                      N ( [ 0 ] , [ 0, 1, 0 ] )   #                          [ 1 ]   [ 0, 0, 1 ]   # truncated at X = 0, and X < Y  < 1   dat <- createContinuousCovariates( 30,                                      mean = \"0,0,1\",                                      names = c(\"X\", \"Y\", \"Z\"),                                      range= c(\"X > 0\", \"X< Y<1\")  )   stopifnot( all( dat$X < dat$Y ) )   stopifnot( all( dat$X > 0 ) )    # 30 samples from a :      [ 0 ]   [ 1 , .5, 0 ]   #                      N ( [ 0 ] , [ .5, 1 , 0 ] )   #                          [ 1 ]   [ 0 , 0 , 1 ]   dat1 <- createContinuousCovariates( 30,                                       mean = \"0,0,1\",                                       names = c(\"X\", \"Y\", \"Z\"),                                       covariance = \"1,.5,1,0,0,1\",                                       seed = 30  )    # same   dat2 <- createContinuousCovariates( 30,                                       mean = \"0,0,1\",                                       names = c(\"X\", \"Y\", \"Z\"),                                       covariance = cbind(c(1,.5,0),                                                          c(.5,1,0),                                                          c(0,0,1)) ,                                       seed = 30  )    stopifnot( all(dat1 == dat2 ))   # use of the digits argument   # X will be rounded at 2 digits   # Y will be rounded at 3 digits   # Z will be rounded at 2 digits   createContinuousCovariates( 10,                               mean = \"100,100,100\",                               names = c(\"X\", \"Y\", \"Z\"),                               digits = \"2,3,2\"  ) #>    SUBJ      X       Y      Z #> 1     1  99.53  99.822  99.08 #> 2     2  98.03 101.550 100.27 #> 3     3 100.12  98.669  99.43 #> 4     4  99.72  99.267 100.07 #> 5     5 100.67  98.519  98.98 #> 6     6  98.96 100.178 101.68 #> 7     7  99.97  99.585  99.25 #> 8     8 100.58 102.139 100.42 #> 9     9  99.80 100.712 100.00 #> 10   10 101.07  99.521  99.54"},{"path":"/reference/createCovariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Create covariates — createCovariates","title":"Create covariates — createCovariates","text":"Function create covariates. Discrete, continuous /external file. function acts wrapper functions : createContinuousCovariates, createDiscreteCovariates, createDiscreteCovariates createTimeVaryingCovariates","code":""},{"path":"/reference/createCovariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create covariates — createCovariates","text":"","code":"createCovariates(   subjects,   conNames = NULL,   conMean,   conCov,   conRange = NULL,   conDigits,   conMaxDraws = 100,   disNames = NULL,   disValues,   disProbs,   disProbArray,   extNames = NULL,   extFile,   extSubset,   extRefCol,   extSameRow = TRUE,   extDataId = idCol,   workingPath = getwd(),   timeNames = NULL,   timeMean,   timeCov,   timeRange = NULL,   timeCol = getEctdColName(\"Time\"),   timePeriod,   idCol = getEctdColName(\"Subject\"),   seed = .deriveFromMasterSeed() )"},{"path":"/reference/createCovariates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create covariates — createCovariates","text":"subjects (Required) Subjects create covariates conNames, conMean, conCov, conRange, conDigits, conMaxDraws (Optional) Arguments createContinuousCovariates function.  createContinuousCovariates function called arguments provided disNames, disValues, disProbs, disProbArray (Optional) Arguments createDiscreteCovariates function.  createDiscreteCovariates function called arguments provided extNames, extFile, extSubset, extRefCol, extSameRow, extDataId (Optional) Arguments createExternalCovariates function.  createExternalCovariates function called arguments provided workingPath (Optional) Working directory import covariate data.  default, current working directory used timeNames, timeMean, timeCov, timeRange, timeCol, timePeriod (Optional) Arguments createTimeVaryingCovariates function.  createTimeVaryingCovariates function called arguments provided idCol (Optional) Name subject column. Must valid R name (See validNames) found anyone conNames, extNames disNames.  \"SUBJ\" used default seed (Optional) Random seed use lower-level functions. default, derived current random seed","code":""},{"path":"/reference/createCovariates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create covariates — createCovariates","text":"Data frame merging results lower-level functions : createContinuousCovariates, createDiscreteCovariates, createExternalCovariates createTimeVaryingCovariates","code":""},{"path":"/reference/createCovariates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create covariates — createCovariates","text":"According presence \"names\" argument, function calls lower-level functions generate covariates.  example, conNames given, function attempt generate covariates continuous distribution using createContinuousCovariates function. names given, data frame containing subject column created. createTimeVaryingCovariates invoked, additional TIME column included output data. Arguments systematically passed lower-level function according name convention.  example, conRange argument passed createContinuousCovariates range argument, extFile passed createExternalCovariates file argument, ...","code":""},{"path":"/reference/createCovariates.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Create covariates — createCovariates","text":"function generate error duplicated names conNames, extNames, disNames, timeNames idCol.","code":""},{"path":[]},{"path":"/reference/createCovariates.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create covariates — createCovariates","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/createCovariates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create covariates — createCovariates","text":"","code":"## unit tests for the covariates component of the MSToolkit package   if (FALSE) {     file.show( system.file( \"Runit\", \"runit.data.covariates.R\", package = \"MSToolkit\") )      wPath <- system.file( \"Runit\", \"data\", \"createCovariates\", package = \"MSToolkit\")     dAll <- createCovariates( 30,       conNames = \"X,Y\", conMean = \"0,0\" , conCov = \"1,0,1\", conRange = \"-1<X<1\",  # continuous       disNames = \"P1,P2\", disValues = \"1,2#3,5,6\" , disProbs = \".5,.5#.3,.3,.4\",  # discrete       extNames = \"X1\", extFile = \"testCovariates.csv\", workingPath = wPath )      # external      dAllwithtime <- createCovariates( 30,       conNames = \"X,Y\", conMean = \"0,0\" , conCov = \"1,0,1\", conRange = \"-1<X<1\", # continuous       disNames = \"P1,P2\", disValues = \"1,2#3,5,6\" , disProbs = \".5,.5#.3,.3,.4\", # discrete       timeNames = \"T1,T2\", timeMean = list(1:3, 1:3), timeCov = list(1, 1:3),    # time-varying       timePeriod = 1:3, extNames = \"X1\", extFile = \"testCovariates.csv\",         # external       workingPath = wPath )  }"},{"path":"/reference/createDirectories.html","id":null,"dir":"Reference","previous_headings":"","what":"Create replicate data, micro evaluation, and macro evaluation directories — createDirectories","title":"Create replicate data, micro evaluation, and macro evaluation directories — createDirectories","text":"function creates directories holding data current scenario. directories hold replicate data, micro evaluation data macro evaluation data.","code":""},{"path":"/reference/createDirectories.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create replicate data, micro evaluation, and macro evaluation directories — createDirectories","text":"","code":"createDirectories(   dirNames = c(\"ReplicateData\", \"MicroEvaluation\", \"MacroEvaluation\"),   workingPath = getwd(),   warn = FALSE,   method = getEctdDataMethod() )"},{"path":"/reference/createDirectories.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create replicate data, micro evaluation, and macro evaluation directories — createDirectories","text":"dirNames (Optional) vector directories create \"workingPath\" directory.  default, directories \"ReplicateData\", \"MicroEvaluation\" \"MacroEvaluation\" created workingPath (Optional) working directory create directories.  current working directory used default warn (Optional) logical value.  warnings directory creation shown?  FALSE default method Data storage method (given getEctdDataMethod default). MSToolkit can work externalised data (.csv .RData files) internal data format, replicate data stored list data frames internal environment (.ectdEnv$DataStore)","code":""},{"path":"/reference/createDirectories.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create replicate data, micro evaluation, and macro evaluation directories — createDirectories","text":"logical vector length \"dirNames\", indicating whether corresponding directories successfully created.","code":""},{"path":"/reference/createDirectories.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create replicate data, micro evaluation, and macro evaluation directories — createDirectories","text":"Attempts create directories named character vector \"dirNames\" within \"workingPath\" directory.  action taken method \"Internal\"","code":""},{"path":"/reference/createDirectories.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create replicate data, micro evaluation, and macro evaluation directories — createDirectories","text":"Francisco Gochez","code":""},{"path":"/reference/createDirectories.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create replicate data, micro evaluation, and macro evaluation directories — createDirectories","text":"","code":"if (FALSE) {     # Create 2 of the 3 directories     createDirectories(dirNames = c(\"ReplicateData\", \"MicroEvaluation\"))   }"},{"path":"/reference/createDiscreteCovariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Create covariates from a discrete distribution — createDiscreteCovariates","title":"Create covariates from a discrete distribution — createDiscreteCovariates","text":"values probs argument parsed using parseHashString helper function. either :   - vector giving values variable.     c(\"1,2\", \"1,2,3\") mean first variable takes values     1 2, second variable takes values 1, 2 3.   - list giving values variable.   list(c(1,2), c(1,2,3)) mean first variable takes   values 1 2, second variable takes values 1, 2 3.   - compact notation using hash symbol separate variables   \"1,2#1,2,3\"","code":""},{"path":"/reference/createDiscreteCovariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create covariates from a discrete distribution — createDiscreteCovariates","text":"","code":"createDiscreteCovariates(   subjects,   names,   values,   probs,   probArray,   seed = .deriveFromMasterSeed(),   idCol = getEctdColName(\"Subject\"),   includeIDCol = TRUE )"},{"path":"/reference/createDiscreteCovariates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create covariates from a discrete distribution — createDiscreteCovariates","text":"subjects (Required) Vector subjects (number subjects) create covariates names (Required) Names discrete covariates created.  names valid R names. See link{validNames}. values (Required) Values covariates can take. See details section. probs (Optional) Probabilities covariates. See details section. probArray (Optional) Probability array uneven sampling. See details section. seed (Optional) Random seed use.default, based current random seed idCol (Optional) Name subject column.  Must valid R name (see validNames) duplicated names. \"SUBJ\" default includeIDCol (Optional) logical value. subject column ","code":""},{"path":"/reference/createDiscreteCovariates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create covariates from a discrete distribution — createDiscreteCovariates","text":"data frame.","code":""},{"path":"/reference/createDiscreteCovariates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create covariates from a discrete distribution — createDiscreteCovariates","text":"Additionally probs argument, check performed make sure variable probability sums 1. Alternatively, probArray argument can given. data frame containing one column (named \"prob\") number variables create. variable column contains values can take. prob column gives probability combination. See examples. prob column sum one.","code":""},{"path":[]},{"path":"/reference/createDiscreteCovariates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create covariates from a discrete distribution — createDiscreteCovariates","text":"","code":"# 10 samples of X and Y where:   # P[ X = 1 ] = .1   # P[ X = 2 ] = .9   # -   # P[ Y = 7 ] = .5   # P[ Y = 8 ] = .4   # P[ Y = 9 ] = .1   createDiscreteCovariates( 10 ,                             names = \"X, Y\",                             probs = \".1,.9#.5,.4,.1\",                             values = \"1,2#7,8,9\") #>    SUBJ X Y #> 1     1 2 7 #> 2     2 2 8 #> 3     3 2 8 #> 4     4 2 7 #> 5     5 2 8 #> 6     6 2 8 #> 7     7 2 7 #> 8     8 2 7 #> 9     9 1 7 #> 10   10 1 7   # using the probArray version   pa <- data.frame( F1 = rep(0:1, 3),                     F2 = rep(1:3, each = 2),                     PROB = c(.1,.2,.1,.2,.2,.2) )    createDiscreteCovariates( 100 , probArray = pa ) #>     SUBJ F1 F2 #> 1      1  1  2 #> 2      2  0  1 #> 3      3  1  1 #> 4      4  1  2 #> 5      5  1  1 #> 6      6  1  1 #> 7      7  0  3 #> 8      8  1  1 #> 9      9  0  3 #> 10    10  0  3 #> 11    11  1  3 #> 12    12  1  1 #> 13    13  1  3 #> 14    14  1  2 #> 15    15  1  1 #> 16    16  0  3 #> 17    17  0  3 #> 18    18  1  3 #> 19    19  1  2 #> 20    20  0  3 #> 21    21  1  1 #> 22    22  1  3 #> 23    23  1  3 #> 24    24  1  3 #> 25    25  1  1 #> 26    26  1  2 #> 27    27  1  3 #> 28    28  1  3 #> 29    29  1  3 #> 30    30  1  2 #> 31    31  1  1 #> 32    32  1  3 #> 33    33  0  1 #> 34    34  1  2 #> 35    35  0  3 #> 36    36  1  2 #> 37    37  0  1 #> 38    38  1  3 #> 39    39  1  1 #> 40    40  1  1 #> 41    41  1  2 #> 42    42  1  2 #> 43    43  1  2 #> 44    44  0  2 #> 45    45  0  3 #> 46    46  0  2 #> 47    47  1  1 #> 48    48  1  2 #> 49    49  1  2 #> 50    50  1  2 #> 51    51  0  2 #> 52    52  1  1 #> 53    53  0  3 #> 54    54  1  1 #> 55    55  0  1 #> 56    56  0  3 #> 57    57  1  3 #> 58    58  0  2 #> 59    59  0  3 #> 60    60  1  1 #> 61    61  0  2 #> 62    62  0  1 #> 63    63  1  1 #> 64    64  1  1 #> 65    65  1  2 #> 66    66  1  2 #> 67    67  1  3 #> 68    68  1  2 #> 69    69  0  3 #> 70    70  1  1 #> 71    71  1  3 #> 72    72  0  3 #> 73    73  1  2 #> 74    74  0  3 #> 75    75  0  3 #> 76    76  0  3 #> 77    77  0  3 #> 78    78  1  2 #> 79    79  0  3 #> 80    80  1  1 #> 81    81  0  3 #> 82    82  0  1 #> 83    83  1  1 #> 84    84  1  1 #> 85    85  0  2 #> 86    86  1  2 #> 87    87  1  1 #> 88    88  1  2 #> 89    89  1  1 #> 90    90  0  1 #> 91    91  0  3 #> 92    92  1  3 #> 93    93  1  1 #> 94    94  1  2 #> 95    95  1  1 #> 96    96  0  1 #> 97    97  1  1 #> 98    98  1  3 #> 99    99  0  3 #> 100  100  1  2"},{"path":"/reference/createDropout.html","id":null,"dir":"Reference","previous_headings":"","what":"Adds dropout to a simulated dataset — createDropout","title":"Adds dropout to a simulated dataset — createDropout","text":"Applies given dropout function simulated trial dataset, order create \"missing\" variable representing subject dropout","code":""},{"path":"/reference/createDropout.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adds dropout to a simulated dataset — createDropout","text":"","code":"createDropout(   data,   dropFunc,   seed = .deriveFromMasterSeed(),   idCol = getEctdColName(\"Subject\"),   timeCol = getEctdColName(\"Time\"),   flagName = getEctdColName(\"Missing\"),   ... )"},{"path":"/reference/createDropout.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adds dropout to a simulated dataset — createDropout","text":"data (Required) Data frame add \"missingness\" flag dropFunc (Required) Drop function apply data.  function must return vector booleans seed (Optional) Random generation seed.  default, current random seed used idCol (Optional) name subject varuable data. \"SUBJ\" default timeCol (Optional) name time column data.  \"TIME\" default flagName (Optional) name missing variable create data.  \"MISSING\" default ... (Optional) Extra arguments passed directly dropout function.  arguments passed default","code":""},{"path":"/reference/createDropout.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adds dropout to a simulated dataset — createDropout","text":"updated data frame added/updated \"missing\" column","code":""},{"path":"/reference/createDropout.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adds dropout to a simulated dataset — createDropout","text":"function accept (check) \"dropout\" function, applied data.  function must return boolean vector.  dropout function supplied applied data provided (possibly extra arguments supplied ellipses).  boolean vector returned, function ensure dropout \"retained\" time within subject (subject drops visit 1, /also missing visits 2, 3 etc.).  \"retained\" boolean vector added dataset (used enhance existing \"missing\" flag) updated data returned.","code":""},{"path":[]},{"path":"/reference/createDropout.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Adds dropout to a simulated dataset — createDropout","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/createDropout.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adds dropout to a simulated dataset — createDropout","text":"","code":"if (FALSE) {  dFun <- function(data, prop) sample(0:1, nrow(data), replace=TRUE, prob=c(1-prop, prop)) createDropout(data=myDf, dropFunc=dFun, prop=.05) #     SUBJ TIME MISSING #  1     1    1       0 #  2     1    2       0 #  3     1    3       0 #  4     1    4       0 #  5     1    5       0 #  6     2    1       0 #  7     2    2       0 #  8     2    3       1 #  9     2    4       1 #  10    2    5       1 #  11    3    1       0 #  12    3    2       1 #  13    3    3       1 #  14    3    4       1 #  15    3    5       1 }"},{"path":"/reference/createEmptyMicro.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an empty micro evaluation data frame — createEmptyMicro","title":"Create an empty micro evaluation data frame — createEmptyMicro","text":"Creates \"empty\" (.e. filled NA values) micro evaluation data frame column names dose column name given arguments.","code":""},{"path":"/reference/createEmptyMicro.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an empty micro evaluation data frame — createEmptyMicro","text":"","code":"createEmptyMicro(   doses,   doseCol = \"DOSE\",   microColumnNames = c(doseName = doseCol, \"MEAN\", \"SE\", \"LOWER\", \"UPPER\", \"N\") )"},{"path":"/reference/createEmptyMicro.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an empty micro evaluation data frame — createEmptyMicro","text":"doses (Required) mixed numeric character vector dose data dose column data frame.  must contain duplicate entries. doseCol (Optional) string indicating name column hold \" doses\" vector.  \"DOSE\" default microColumnNames (Optional) character vector containing names columns micro evaluation data frame.  default, variables \"MEAN\", \"SE\", \"LOWER\", \"UPPER\" \"N\" created addition dose variable","code":""},{"path":"/reference/createEmptyMicro.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an empty micro evaluation data frame — createEmptyMicro","text":"createEmptyMicro returns data frame described .","code":""},{"path":"/reference/createEmptyMicro.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create an empty micro evaluation data frame — createEmptyMicro","text":"createEmptyMicro return data frame whose column names given microColumnNames. first column resulting data frame contain doses vector default.  data frame many rows entries doses.  frame's entries NA. function generate error \"doses\" contains duplicate entries dose column name specified doseCol doeses occur microColumnNames.","code":""},{"path":"/reference/createEmptyMicro.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Create an empty micro evaluation data frame — createEmptyMicro","text":"Future versions MSToolkit relax format MicroEvaluation dataset allowing free structure dataset.","code":""},{"path":[]},{"path":"/reference/createEmptyMicro.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create an empty micro evaluation data frame — createEmptyMicro","text":"Francisco Gochez","code":""},{"path":"/reference/createEmptyMicro.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an empty micro evaluation data frame — createEmptyMicro","text":"","code":"createEmptyMicro(doses = c(10, 20 ,30, 40)) #>   DOSE MEAN SE LOWER UPPER  N #> 1   10   NA NA    NA    NA NA #> 2   20   NA NA    NA    NA NA #> 3   30   NA NA    NA    NA NA #> 4   40   NA NA    NA    NA NA   createEmptyMicro(doses = c(5, 25), doseCol = \"D\", microColumnNames = c(\"D\", \"MEAN\", \"SE\",   \"LOWER\")) #>    D MEAN SE LOWER #> 1  5   NA NA    NA #> 2 25   NA NA    NA"},{"path":"/reference/createExternalCovariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Create covariates by sampling from an external file — createExternalCovariates","title":"Create covariates by sampling from an external file — createExternalCovariates","text":"Create covariates sampling external file.","code":""},{"path":"/reference/createExternalCovariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create covariates by sampling from an external file — createExternalCovariates","text":"","code":"createExternalCovariates(   subjects,   names,   file,   sameRow = TRUE,   subset = NULL,   refCol = NULL,   dataId = idCol,   idCol = getEctdColName(\"Subject\"),   percent = 20,   seed = .deriveFromMasterSeed(),   includeIDCol = TRUE,   refColSuffix = \"refCol\",   workingPath = getwd() )"},{"path":"/reference/createExternalCovariates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create covariates by sampling from an external file — createExternalCovariates","text":"subjects (Required) Number subjects sample sets external covariate values names (Required) Names covariates use file file (Required) Input file name.  either valid csv file NONMEM data file containing variables given names, idCol sameRow (Optional) logical value).  covariates sampled rows sampling done independantly covariate.  Using sameRow = TRUE maintain multivariate structure imported dataset faster.  TRUE default subset (Optional) subset performed imported dataset sampling. subset parsed parseRangeCode function.  subsetting performed default refCol (Optional) reference column data file.  given, output dataset also contain additional column indicating origin row original dataset. option compatible sameRow = FALSE.  default, reference variables used dataId (Optional) subject variable input dataset, equal idCol default.  default, \"idCol\" idCol (Optional) subject variable output dataset.  \"SUBJ\" default percent (Optional) subset performed input data, number rows remaining dataset subset less percent %, function issue warning.  default, 20% used seed (Optional) Random generator seed use.  current random seed used default includeIDCol (Optional) logical value.  subject variable included output dataset?  createCovariates calls function, need subject variable.  TRUE default refColSuffix (Optional) suffix use creating refCol variable.  refCol variable \"SUBJ\", output dataset created \"SUBJ\" suffixed \"refColSuffix\".  default, \"refCol\" used suffix workingPath (Optional) Working path import covariate file.  default, current working directory used","code":""},{"path":"/reference/createExternalCovariates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create covariates by sampling from an external file — createExternalCovariates","text":"data frame containing imported variables, possibly reference variable.","code":""},{"path":"/reference/createExternalCovariates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create covariates by sampling from an external file — createExternalCovariates","text":"sampling always done replacement. refCol setting typically used parameter component, see createParameters createExternalParameters maintain consistency imported covariates imported parameters.","code":""},{"path":[]},{"path":"/reference/createExternalCovariates.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create covariates by sampling from an external file — createExternalCovariates","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/createExternalCovariates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create covariates by sampling from an external file — createExternalCovariates","text":"","code":"if (FALSE) {    # an example file from the unit tests of the MSToolkit package   wPath <- system.file( \"Runit\", \"data\", \"createCovariates\", package = \"MSToolkit\" )    # sample 20 subjects from the example file   dat <- createExternalCovariates( 20, names = \"X1\",     subset = c(\".7 < X1 < .8\", \"-1 <= X2 <= 1\"),     file = \"testCovariates.csv\", workingPath = wPath )   print( dat )    # maintaining the origin of each row   dat <- createExternalCovariates( 20, names = \"X1, X2\",     subset = c(\".7 < X1 < .8\", \"-1 <= X2 <= 1\"),     file = \"testCovariates.csv\", workingPath = wPath, refCol = \"ID\" )   print( dat )  }"},{"path":"/reference/createExternalParameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample parameters from an external file — createExternalParameters","title":"Sample parameters from an external file — createExternalParameters","text":"Create parameters simulated population sampling external file","code":""},{"path":"/reference/createExternalParameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample parameters from an external file — createExternalParameters","text":"","code":"createExternalParameters(   subjects,   file,   names,   range,   betNames,   betNums,   errStruc = c(\"None\", \"Proportional\", \"Additive\", \"Log-Normal\"),   subset = NULL,   refCol,   refColName,   idCol = getEctdColName(\"Subject\"),   seed = .deriveFromMasterSeed(),   flagName = getEctdColName(\"ParOmit\"),   refColSuffix = \"refCol\",   dataId = idCol,   workingPath = getwd() )"},{"path":"/reference/createExternalParameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample parameters from an external file — createExternalParameters","text":"subjects (Required) Number subjects create parameters file (Required) External file extract parameters names (Required) Names parameters import (refers variables input data) range (Optional) Range acceptable values.  Missing default, resulting \"range\" values applied data betNames (Required) subject effects variables data betNums (Required) Integer vector mapping subject effects onto fixed effects errStruc (Optional) (None) Function map subject effects: Additive, Proportional, Log-Normal None subset (Optional) Subset apply data.  default, subset applied refCol (Optional) Vector data matched reference column sampling (reference data default) refColName (Optional) Column name data referenced sampling (reference column default) idCol (Optional) Subject variable name data (\"SUBJ\" default) seed (Optional) Random number seed.  Derived current seed default flagName (Optional) Name \"parameter omit\" flag (\"PAROMIT\" default) refColSuffix (Optional) Suffix add reference variable data (\"refCol\" default) dataId (Optional) subject variable name data.  default, taken \"idCol\" input workingPath (Optional) Working path import covariate file.  default, working path used","code":""},{"path":"/reference/createExternalParameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample parameters from an external file — createExternalParameters","text":"data frame containing subject variable, \"parameter omit flag\" set extracted parameters","code":""},{"path":"/reference/createExternalParameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample parameters from an external file — createExternalParameters","text":"data first imported specified file, subset applied .  function next checks required variables specifed appear imported data.  Fixed effects (specified using names) selected file along subject effects (also identified). fixed subject effects generated, \"errStruc\" input specify subject effects applied: * None = Keep subject effect seperate (use \"suffix\" supplied name variables) * Additive = Add subject effect corresponding fixed effect * Proportional = Multiply fixed effect exponentiated subject effect * Log-Normal = Add \"1 + subject effect\" corresponding fixed effect relCol input specified, variable also retained result.  \"parameter omit\" flag contain repeated \"0\" elements return result.","code":""},{"path":"/reference/createExternalParameters.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Sample parameters from an external file — createExternalParameters","text":"earlier versions MSToolkit, \"Proportional\" error structure implemented exp(fixed + subject)","code":""},{"path":[]},{"path":"/reference/createExternalParameters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Sample parameters from an external file — createExternalParameters","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/createExternalParameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample parameters from an external file — createExternalParameters","text":"","code":"if (FALSE) {   wPath <- system.file( \"Runit\", \"data\", \"createParameters\", package = \"MSToolkit\" )    createExternalParameters( subjects = 100, names = \"E0,ED50\",     file = \"testParam.csv\", errStruc = \"None\", betNames = \"B1,B2\", workingPath = wPath ) }"},{"path":"/reference/createInterims.html","id":null,"dir":"Reference","previous_headings":"","what":"Create the interim flag — createInterims","title":"Create the interim flag — createInterims","text":"clinical trials sometimes need examine emerging data trial progresses make decisions curtailing trial early, either due lack efficacy statistical significance achieved unethical continue allocating patients inferior treatments. interim assessments usually performed specified proportion subjects completed treatment. Thus, cumulative proportion patients eligible interim assessment. MSToolkit allows user specify cumulative proportion allocates subjects interim assessment.","code":""},{"path":"/reference/createInterims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create the interim flag — createInterims","text":"","code":"createInterims(   subjects,   proportion,   seed = .deriveFromMasterSeed(),   idCol = getEctdColName(\"Subject\"),   interimCol = getEctdColName(\"Interim\"),   method = \"Sample\" )"},{"path":"/reference/createInterims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create the interim flag — createInterims","text":"subjects (Required) Vector subjects number subjects proportion (Required) Vector proportions subjects interim.  vector cumulative proportions seed (Optional) random number generation seed use.  default, derived current random seed idCol (Optional) Name subject column (\"SUBJ\" default) interimCol (Optional) Name interim column (\"INTERIM\" default) method (Optional) Method use. Must one Sample Proportion.  Default Sample","code":""},{"path":"/reference/createInterims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create the interim flag — createInterims","text":"data frame containing following variables: SUBJ Subject identifier, named idCol. INTERIM Interim flag, named interimCol.","code":""},{"path":"/reference/createInterims.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create the interim flag — createInterims","text":"function creates INTERIM flag identifies interim analysis FIRST subject \"method\" argument set \"Sample\", interim numbers assigned using following algorithm: Store number subjects (nSubjects) number interims (nInterims) Append zero start proportions take differences get vector \"non-cumulative\" probabilities Take \"nSubjects\" samples values \"1\" \"nInterims\" probabilities set derived \"non-cumulative\" probabilities Replace \"interim\" variable values. \"method\" argument set \"Proportion\", interim numbers assigned using following algorithm: Store number subjects (nSubjects) number interims (nInterims) Convert cumulative proportions \"non-cumulative\" probabilities. Allocate \"base\" number subjects interim (found multiplying nSubjects set probabilities, take floor resulting values) subjects left stage, use \"sample\" method () allocate remaining subjects interims \"Shuffle\" interim variable results ordered.","code":""},{"path":"/reference/createInterims.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create the interim flag — createInterims","text":"Romain Francois","code":""},{"path":"/reference/createInterims.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create the interim flag — createInterims","text":"","code":"# first interim with 10% of the subjects   # second with 30%   # third with 60%   interims <- createInterims(100, proportion  = \".1,.3,.6\" )   prop.table(table(interims$INTERIM)) #>  #>    1    2    3    4  #> 0.14 0.20 0.32 0.34     if (FALSE) {     ## more examples in the unit tests     file.show( system.file(\"Runit\", \"runit.data.interim.R\",                 package = \"MSToolkit\") )   }"},{"path":"/reference/createMCAR.html","id":null,"dir":"Reference","previous_headings":"","what":"Missing Completely at Random — createMCAR","title":"Missing Completely at Random — createMCAR","text":"function adds (modifies) \"MISSING\" flag dataset simulate missing completely random behaviour.","code":""},{"path":"/reference/createMCAR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Missing Completely at Random — createMCAR","text":"","code":"createMCAR(   data,   prop = 0,   rule,   seed = .deriveFromMasterSeed(),   flagName = getEctdColName(\"Missing\") )"},{"path":"/reference/createMCAR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Missing Completely at Random — createMCAR","text":"data (Required) Data frame add missingness prop (Optional) proportion missingness 0 1.  default \"0\" (missingness generated) rule (Optional) observations matching rule can flagged missing.  default, observations available missing seed (Optional) Random seed use.  Based current random seed default flagName (Optional) name missing flag (\"MISSING\" default)","code":""},{"path":"/reference/createMCAR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Missing Completely at Random — createMCAR","text":"data argument MISSING flag added modified.","code":""},{"path":"/reference/createMCAR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Missing Completely at Random — createMCAR","text":"missing data either added dataset modified already exist. latter case, function overwrites data already missing.","code":""},{"path":[]},{"path":"/reference/createMCAR.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Missing Completely at Random — createMCAR","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/createMCAR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Missing Completely at Random — createMCAR","text":"","code":"myData <- data.frame(   SUBJ   = rep(1:3, each = 3),   TIME = rep(0:2, 3)  ) createMCAR( myData, prop = 0.1, rule = \"TIME > 0\") #>   SUBJ TIME MISSING #> 1    1    0       0 #> 2    1    1       0 #> 3    1    2       0 #> 4    2    0       0 #> 5    2    1       0 #> 6    2    2       0 #> 7    3    0       0 #> 8    3    1       0 #> 9    3    2       0  if (FALSE) {  ## more examples in the unit tests  file.show( system.file( \"Runit\", \"runit.data.missing.R\" , package = \"MSToolkit\") ) }"},{"path":"/reference/createNmMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a matrix based on a ","title":"Creates a matrix based on a ","text":"Creates matrix based vector specifying lower diagonal elements (defined NONMEM outputs)","code":""},{"path":"/reference/createNmMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a matrix based on a ","text":"","code":"createNmMatrix(x, dimnames = NULL, byrow = TRUE)"},{"path":"/reference/createNmMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a matrix based on a ","text":"x Vector values placed matrix dimnames Optional dimension names output matrix byrow (Optional) read data matrix diagonal row (default) column","code":""},{"path":"/reference/createNmMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a matrix based on a ","text":"matrix","code":""},{"path":"/reference/createNmMatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates a matrix based on a ","text":"Places values lower diagonal output matrix, reflects values across diagonal.  Adds dimension names provided","code":""},{"path":"/reference/createNmMatrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Creates a matrix based on a ","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/createNmMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a matrix based on a ","text":"","code":"createNmMatrix(1:3) #>      [,1] [,2] #> [1,]    1    2 #> [2,]    2    3   createNmMatrix(1:6) #>      [,1] [,2] [,3] #> [1,]    1    2    4 #> [2,]    2    3    5 #> [3,]    4    5    6   createNmMatrix(1:10, list(LETTERS[1:4], letters[1:4])) #>   a b c  d #> A 1 2 4  7 #> B 2 3 5  8 #> C 4 5 6  9 #> D 7 8 9 10"},{"path":"/reference/createNormalParameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Create parameters based on a multivariate normal distribution — createNormalParameters","title":"Create parameters based on a multivariate normal distribution — createNormalParameters","text":"Creates parameter variables sampling multivariate normal distribution. Parameter values can vary simulation replicates, also subjects within simulation replicate (subject variability).","code":""},{"path":"/reference/createNormalParameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create parameters based on a multivariate normal distribution — createNormalParameters","text":"","code":"createNormalParameters(   subjects,   names,   mean,   covariance = 0,   range,   betNames,   betMean = 0,   betCov = 0,   errStruc = c(\"None\", \"Proportional\", \"Additive\", \"Log-Normal\"),   suffix = \".Between\",   idCol = getEctdColName(\"Subject\"),   maxDraws = 10,   seed = .deriveFromMasterSeed(),   flagName = getEctdColName(\"ParOmit\"),   digits = 3,   parRangeTolerance = 0.5 )"},{"path":"/reference/createNormalParameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create parameters based on a multivariate normal distribution — createNormalParameters","text":"subjects (Required) Subjects create parameters names (Required) Names parameters generate mean (Required) Means fixed parameters covariance (Optional) Covariance matrix fixed parameters.  default, matrix zeros, representing error included range (Optional) Range acceptable values.  Missing default, resulting \"range\" values applied data betNames (Optional) subject effects create.  Default create subject data betMean (Optional) Means subject effects.  Default create subject data betCov (Optional) Covariance matrix subject effects. Default create subject data errStruc (Optional) (None) Function map subject effects: Additive, Proportional, Log-Normal None suffix (Optional) Suffix use retain subject effects (default \".\") idCol (Optional) Subject variable name return data (\"SUBJ\" default) maxDraws (Optional) Maximum number iterations valid parameters (10 default) seed (Optional) Random number generation seed.  default, dervied current random seed flagName (Optional) Flag name parameters bounds (\"PAROMIT\" default) digits (Optional) Number digits round generated continuous parameters.  Can atomic integer, case variables rounded according . Can numeric vector length number fixed parameters, case parameter rounded according value.  default 3 parRangeTolerance (Optional, default .9) Proportion subjects parameters specified range acceptable us continue","code":""},{"path":"/reference/createNormalParameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create parameters based on a multivariate normal distribution — createNormalParameters","text":"data frame containing parameter data","code":""},{"path":"/reference/createNormalParameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create parameters based on a multivariate normal distribution — createNormalParameters","text":"function first samples new value parameter. parameter value used subject within trial replicate. values generated multivariate normal distribution mean covariance matrix specified within function arguments. can viewed \"fixed effects\" trial replicate. \"betNames\" argument supplied (\"betNames\" must subset parameter names supplied \"names\" argument) another sample taken generate subject-specific parameter values. \"betMean\" input supplied, mean effects distribution 0.  Samples subject taken multivariate normal distribution mean \"betMean\" covariate matrix \"betCov\". \"betCov\" specifies subject variability parameters. fixed subject effects generated, \"errStruc\" input specify subject effects applied: * None = Keep subject effect separate (use \"suffix\"   supplied name variables)   * Additive = Add subject effect corresponding fixed   effect   * Proportional = Multiply fixed effect exponentiated   subject effect   * Log-Normal = Add \"1 + subject effect\" corresponding   fixed effect \"range\" argument provided, output algorithm (fixed + ) checked acceptance range.  data within range, function take \"maxDraws\" attempts algorithm try generate \"range\" data.  possible, function stop return error.","code":""},{"path":"/reference/createNormalParameters.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Create parameters based on a multivariate normal distribution — createNormalParameters","text":"earlier versions MSToolkit, \"Proportional\" error structure implemented exp(fixed + subject)","code":""},{"path":"/reference/createNormalParameters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create parameters based on a multivariate normal distribution — createNormalParameters","text":"Rich Pugh","code":""},{"path":"/reference/createNormalParameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create parameters based on a multivariate normal distribution — createNormalParameters","text":"","code":"createNormalParameters(5, \"E0,ED50,EMAX\",                        mean = c(0, 50, 100),                        covariance = diag(c(1, 5, 10))) #>   SUBJ    E0   ED50    EMAX PAROMIT #> 1    1 1.849 46.618 102.745       0 #> 2    2 1.849 46.618 102.745       0 #> 3    3 1.849 46.618 102.745       0 #> 4    4 1.849 46.618 102.745       0 #> 5    5 1.849 46.618 102.745       0 #  SUBJ       E0     ED50     EMAX   PAROMIT #1    1 -0.8356286 50.41064 98.01898       0 #2    2 -0.8356286 50.41064 98.01898       0 #3    3 -0.8356286 50.41064 98.01898       0 #4    4 -0.8356286 50.41064 98.01898       0 #5    5 -0.8356286 50.41064 98.01898       0  createNormalParameters(5, \"E0,ED50,EMAX\",                        mean = c(0, 50, 100),                        covariance = diag(c(1, 5, 10)),                        betNames = c(\"E0\", \"EMAX\"),                        betCov = diag(2),                        errStruc = \"Additive\") #>   SUBJ     E0   ED50   EMAX PAROMIT #> 1    1 -0.085 47.633 96.318       0 #> 2    2  0.039 47.633 97.672       0 #> 3    3 -0.462 47.633 97.402       0 #> 4    4 -2.106 47.633 96.946       0 #> 5    5  0.150 47.633 97.188       0 #  SUBJ       E0     ED50     EMAX   PAROMIT #1    1  0.7596522 50.41064 98.59476       0 #2    2 -0.5061208 50.41064 97.71359       0 #3    3 -1.6560970 50.41064 99.53076       0 #4    4 -0.3481996 50.41064 98.40882       0 #5    5 -0.0973039 50.41064 97.39774       0  # no covariance by default createNormalParameters(5, \"E0,ED50,EMAX\", mean = c(0, 50, 100) ) #>   SUBJ E0 ED50 EMAX PAROMIT #> 1    1  0   50  100       0 #> 2    2  0   50  100       0 #> 3    3  0   50  100       0 #> 4    4  0   50  100       0 #> 5    5  0   50  100       0 #  SUBJ E0 ED50 EMAX PAROMIT #1    1  0   50  100       0 #2    2  0   50  100       0 #3    3  0   50  100       0 #4    4  0   50  100       0 #5    5  0   50  100       0"},{"path":"/reference/createParameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates parameters for subjects in each replicate — createParameters","title":"Creates parameters for subjects in each replicate — createParameters","text":"Creates simulated fixed subject parameters subjects replicate","code":""},{"path":"/reference/createParameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates parameters for subjects in each replicate — createParameters","text":"","code":"createParameters(   subjects,   genNames,   genFixedMean,   genFixedCov = 0,   genRange,   genBetweenNames,   genBetweenMean,   genBetweenCov,   genErrStruc = \"None\",   genMaxDraws = 10,   genParRangeTolerance = 0.5,   extFile,   extNames,   extBetween,   extBetweenNums,   extSubset,   extRange,   extErrStruc = \"None\",   extRefCol,   extRefColName,   extRefColSuffix,   extIndEffects,   extDataId = idCol,   workingPath = getwd(),   suffix = \".Between\",   idCol = getEctdColName(\"Subject\"),   seed = .deriveFromMasterSeed(),   flagName = getEctdColName(\"ParOmit\") )"},{"path":"/reference/createParameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates parameters for subjects in each replicate — createParameters","text":"subjects Subjects create parameters genNames Names fixed effects generate genFixedMean Means generating fixed parameters genFixedCov Covariance Matrix generating fixed parameter. 0 default. genRange Range Acceptable values derived parameters genBetweenNames subjects effects generate genBetweenMean Means generated subject effects genBetweenCov subject effects covariance. genErrStruc function map effects: Additive, Proportional, Log-Normal None. default \"None\". genMaxDraws maximum number draws. default value 10. genParRangeTolerance proportion subjects \"range\" parameters . default value 0.5. extFile external file name data import. extNames Names parameters import (refers variables input data) extBetween subject effects variables data extBetweenNums integer mapping random fixed effects. extSubset subset applied data sampling. extRange range Acceptable values derived parameters. extErrStruc Function map subject effects: Additive, Proportional, Log-Normal None. default \"None\". extRefCol column reference data. extRefColName column name data referenced sampling. extRefColSuffix Suffix add reference variable data. extIndEffects Individual effects flag extDataId external subject variable name. default, taken \"idCol\" input. workingPath Working path import covariate file. default, working path used suffix Suffix retained subject effects. default \".\". idCol Subject variable name. default getEctdColName(\"Subject\"). seed Random seed. default .deriveFromMasterSeed(). flagName Name omit flag. default getEctdColName(\"ParOmit\").","code":""},{"path":"/reference/createResponse.html","id":null,"dir":"Reference","previous_headings":"","what":"High-level function for the response component. — createResponse","title":"High-level function for the response component. — createResponse","text":"Create response dataset equation.","code":""},{"path":"/reference/createResponse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"High-level function for the response component. — createResponse","text":"","code":"createResponse(   data,   equation,   name = getEctdColName(\"Response\"),   invLink,   distribution = \"normal\",   covariance,   errStruc = \"Additive\",   range,   digits = 3,   seed = .deriveFromMasterSeed(),   flagName = getEctdColName(\"RespOmit\") )"},{"path":"/reference/createResponse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"High-level function for the response component. — createResponse","text":"data (Required) Data structure add response. equation (Required) R function character string creating response. See createResponseVariable. name (Optional) Response variable name (\"RESP\" default) invLink (Optional) Inverse link function predictor. R function.  inverse link function default distribution (Optional) Outcome variable distribution, one \"n\" normal, \"l\" lognormal, \"b\" binomial \"p\" poisson.  Default \"Normal\" covariance (Optional) Residual Error (CO)VARIANCE, passed addResidualError function.  Missing default, resulting residual error generated reponse errStruc (Optional) Function describing apply residual error: \"Additive\", \"Log-Normal\" \"Proportional\".  \"Additive\" default range (Optional) Range acceptable values created response. See parseRangeCode.  Missing default, resulting \"range\" limitation response digits (Optional) Number digits round response (3 default) seed (Optional) Random number seed.  default, derived current random seed flagName (Optional) \"Response Omit\" Flag name (\"RESPOMIT\" default)","code":""},{"path":"/reference/createResponse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"High-level function for the response component. — createResponse","text":"data set containing two columns. RESP actual Response RESPOMIT response OMIT flag. named value flagName argument.","code":""},{"path":"/reference/createResponse.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"High-level function for the response component. — createResponse","text":"earlier versions MSToolkit, \"Proportional\" Error Structure behaved differently (assumed parameters passed log scale)","code":""},{"path":[]},{"path":"/reference/createResponse.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"High-level function for the response component. — createResponse","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/createResponse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"High-level function for the response component. — createResponse","text":"","code":"# example data   myData <- expand.grid(X = 1:2, Y = 1:2, Z = 1:2)    # added to comply with SF issue 7   # Tue Jul 24 10:21:14 BST 2007 @431 /Internet Time/   # function example   out1 <- createResponse(data = myData,                          equation = function(data) with(data, X+Y+Z),                          covariance = 1, range = \"RESP < 3\", seed = 96)    # same example using a character representation   out2 <- createResponse(data = myData,                          equation = \"X+Y+Z\",                          covariance = 1, range = \"RESP < 3\", seed = 96)   stopifnot(identical(out1, out2))"},{"path":"/reference/createResponseVariable.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a response from a data set and an equation — createResponseVariable","title":"Create a response from a data set and an equation — createResponseVariable","text":"Create response data set equation","code":""},{"path":"/reference/createResponseVariable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a response from a data set and an equation — createResponseVariable","text":"","code":"createResponseVariable(data, equation, preTest = TRUE, subsetSize = 5)"},{"path":"/reference/createResponseVariable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a response from a data set and an equation — createResponseVariable","text":"data (Required) dataset use, must data.frame equation (Required) R function must data argument character string describing equation uses names variables data. preTest (Optional) Logical Flag. TRUE try build response first subset data. subset size given minimum number rows data subsetSize argument. subsetSize (Optional) Size subset preTest requested.","code":""},{"path":"/reference/createResponseVariable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a response from a data set and an equation — createResponseVariable","text":"numeric vector corresponding response variable.","code":""},{"path":"/reference/createResponseVariable.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a response from a data set and an equation — createResponseVariable","text":"Using preTest make function fail early code wrong.  typically useful first steps try error. user confident equation correct, preTest can set FALSE.","code":""},{"path":[]},{"path":"/reference/createResponseVariable.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a response from a data set and an equation — createResponseVariable","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/createResponseVariable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a response from a data set and an equation — createResponseVariable","text":"","code":"# define a data set   myData <- data.frame(X = c(1,2,1), Y = c(1,1,1), Z = c(1,1,1))    # added to comply with SF issue 7   # Tue Jul 24 10:20:20 BST 2007 @430 /Internet Time/   # function version   out1 <- createResponseVariable(data = myData, equation = function(data){     with(data, X + Y + Z)   })    # same using the character version   out2 <- createResponseVariable(data = myData, equation = \"X+Y+Z\")   stopifnot(identical(out1,out2))"},{"path":"/reference/createTimeVaryingCovariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a set of time-varying covariates — createTimeVaryingCovariates","title":"Create a set of time-varying covariates — createTimeVaryingCovariates","text":"Creates set time-varying covariates multivariate normal distribution (optionally) set constraints.","code":""},{"path":"/reference/createTimeVaryingCovariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a set of time-varying covariates — createTimeVaryingCovariates","text":"","code":"createTimeVaryingCovariates(   subjects,   names,   mean,   covariance = 0,   range = NULL,   digits,   maxDraws = 100,   seed = .deriveFromMasterSeed(),   idCol = getEctdColName(\"Subject\"),   timeCol = getEctdColName(\"Time\"),   treatPeriod )"},{"path":"/reference/createTimeVaryingCovariates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a set of time-varying covariates — createTimeVaryingCovariates","text":"subjects (Required) Subjects create covariates names (Required) Names continuous covariates.  valid R names (See validNames) duplicate name given mean (Required) List means. Must length names. vector, time point use value covariance (Optional) Lower triangle covariance matrix. See parseCovMatrix details.  list. vector, time point use value range (Optional) Ranges acceptable values covariates. See parseRangeCode details.  list. covariates range, components set NULL digits (Optional) Number digits used round values.  argument can either missing (default), rounding done, length one variables rounded digits, length number covariates covariate rounded according value. argument first parsed parseCharInput can either character vector numeric vector.  See parseCharInput.  parsed digits vector length one length equal number covariates, error generated ectdStop function.  missing default, resulting rounding performed maxDraws (Optional) Maximum number attempts allowed initial data range (100 default) seed (Optional) Random seed use.  default, derived current random seed idCol (Optional) Name subject column. Must valid R name (See validNames) equal one entry names. \"SUBJ\" default timeCol (Optional) Name time column. Must valid R name (See validNames) equal one entry names. \"TIME\" default treatPeriod Vector time points","code":""},{"path":[]},{"path":"/reference/createTimeVaryingCovariates.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a set of time-varying covariates — createTimeVaryingCovariates","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/createTimeVaryingCovariates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a set of time-varying covariates — createTimeVaryingCovariates","text":"","code":"# same  dat <- createTimeVaryingCovariates(10, \"X, Y, Z\",   mean <- list(X = 1:4, Y = rep(3, 4), Z = \"2.5, 3, 3.2, 3.6\"),   covariance = list(1, 2:5, cbind(c(1,.5,.3,0), c(.5,1,0,0), c(.3,0,1,0), c(0,0,0,1))),   range = list(\"10>=X>0\", NULL, c(\"Z>0\", \"Z<=10\")),   idCol = \"SUBJ\", timeCol = \"TIME\", treatPeriod = c(0.25, 0.5, 1, 12))"},{"path":"/reference/createTreatments.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Treatment Design Data — createTreatments","title":"Create Treatment Design Data — createTreatments","text":"Create treatment group Parallel Crossover design","code":""},{"path":"/reference/createTreatments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Treatment Design Data — createTreatments","text":"","code":"createTreatments(   doses,   times = NULL,   type = \"Parallel\",   sequence,   doseCol = getEctdColName(\"Dose\"),   timeCol = getEctdColName(\"Time\"),   trtCol = getEctdColName(\"Trt\") )"},{"path":"/reference/createTreatments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Treatment Design Data — createTreatments","text":"doses (Required) Vector doses use.  Alternatively can comma separated string numbers times (Optional) Vector time points dosing.  time element default type (Optional) Type dosing regime create: \"Parallel\" \"Crossover\".  \"Parallel\" default.  See \"details\" section. sequence (Optional) Crossover sequence matrix.  default, crossover performed.  See \"details\" section. doseCol (Optional) Dose variable name create (\"DOSE\" default) timeCol (Optional) Time variable name create (\"TIME\" default) trtCol (Optional) Treatment variable name create (\"TRT\" default)","code":""},{"path":"/reference/createTreatments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Treatment Design Data — createTreatments","text":"data frame containing treatment, dose (optionally) time variable","code":""},{"path":"/reference/createTreatments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Treatment Design Data — createTreatments","text":"function first check required inputs.  type \"Parallel\", doses must provided.  type \"Crossover\", sequence matrix must provided. dose type \"Parallel\" specified \"times\", function create data frame Treatment set \"1 number doses\" Dose variable doses specified.  dose type \"Parallel\" specified \"times\" vector, function create data frame parallel treatment regime dose specified. dose type \"Crossover\", specified \"times\" input, \"times\" input set \"1 number rows sequence matrix\" \"times\" supplied, leading non-positive elements, sequence matrix appended set run-measurements (dose set 0).  Based \"times\" \"sequence\" matrix, data frame created aligning column matrix times specified.","code":""},{"path":[]},{"path":"/reference/createTreatments.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create Treatment Design Data — createTreatments","text":"Roman Francois","code":""},{"path":"/reference/createTreatments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Treatment Design Data — createTreatments","text":"","code":"createTreatments(doses = c(0, 15, 30)) #>   TRT DOSE #> 1   1    0 #> 2   2   15 #> 3   3   30 #  TRT DOSE # 1   1    0 # 2   2   15 # 3   3   30 createTreatments(doses = c(0, 15, 30), times = 0:2) #>   TRT TIME DOSE #> 1   1    0    0 #> 2   1    1    0 #> 3   1    2    0 #> 4   2    0   15 #> 5   2    1   15 #> 6   2    2   15 #> 7   3    0   30 #> 8   3    1   30 #> 9   3    2   30 #  TRT TIME DOSE # 1   1    0    0 # 2   1    1    0 # 3   1    2    0 # 4   2    0    0 # 5   2    1   15 # 6   2    2   15 # 7   3    0    0 # 8   3    1   30 # 9   3    2   30  createTreatments(sequence = cbind(c(0, 15, 30), c(15, 30, 0), c(30, 0, 15))) #>   TRT TIME DOSE #> 1   1    1    0 #> 2   1    2   15 #> 3   1    3   30 #> 4   2    1   15 #> 5   2    2   30 #> 6   2    3    0 #> 7   3    1   30 #> 8   3    2    0 #> 9   3    3   15 #  TRT TIME DOSE # 1   1    1    0 # 2   1    2   15 # 3   1    3   30 # 4   2    1   15 # 5   2    2   30 # 6   2    3    0 # 7   3    1   30 # 8   3    2    0 # 9   3    3   15  createTreatments(sequence = cbind(c(0, 15, 30),                                   c(15, 30, 0),                                   c(30, 0, 15)),                                   times = 0:3) #>    TRT TIME DOSE #> 1    1    0    0 #> 2    1    1    0 #> 3    1    2   15 #> 4    1    3   30 #> 5    2    0    0 #> 6    2    1   15 #> 7    2    2   30 #> 8    2    3    0 #> 9    3    0    0 #> 10   3    1   30 #> 11   3    2    0 #> 12   3    3   15 #    TRT TIME DOSE # 1    1    0    0 # 2    1    1    0 # 3    1    2   15 # 4    1    3   30 # 5    2    0    0 # 6    2    1   15 # 7    2    2   30 # 8    2    3    0 # 9    3    0    0 # 10   3    1   30 # 11   3    2    0 # 12   3    3   15"},{"path":"/reference/createTvDefinition.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ","title":"Create ","text":"Create \"Typical Value\" Definition use \"SIMON\" typical value simulation","code":""},{"path":"/reference/createTvDefinition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ","text":"","code":"createTvDefinition(   drugName,   drugValue,   doses,   times = NULL,   type = c(\"Parallel\", \"Crossover\"),   sequence,   testCall = TRUE )"},{"path":"/reference/createTvDefinition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create ","text":"drugName ... drugValue ... doses ... times ... type ... sequence ... testCall ...","code":""},{"path":"/reference/createTvDefinition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create ","text":"\"tvDefinition\" object","code":""},{"path":"/reference/createTvDefinition.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create ","text":"Constructs \"tvDefinition\" object","code":""},{"path":"/reference/createTvDefinition.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create ","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/createTvDefinition.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create ","text":"","code":"createTvDefinition(\"A\", 1, 1:3) #> An object of class \"tvDefinition\" #> Slot \"Name\": #> [1] \"A\" #>  #> Slot \"Value\": #> [1] 1 #>  #> Slot \"trtCall\": #> $doses #> [1] 1 2 3 #>  #> $times #> NULL #>  #> $type #> [1] \"Parallel\" #>  #>"},{"path":"/reference/ectdStop.html","id":null,"dir":"Reference","previous_headings":"","what":"Error handling functions for the ectd package. — ectdStop","title":"Error handling functions for the ectd package. — ectdStop","text":"functions alias standard R functions stop warning, also character interpolation. See examples.","code":""},{"path":"/reference/ectdStop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Error handling functions for the ectd package. — ectdStop","text":"","code":"ectdStop(msg, call. = TRUE, domain = NULL, verbose = getEctdVerbose())  ectdWarning(..., call. = TRUE, immediate. = FALSE, domain = NULL)"},{"path":"/reference/ectdStop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Error handling functions for the ectd package. — ectdStop","text":"msg (Required) Message displayed user call. logical, indicating call become part     error message. domain see gettext.  NA, messages     translated. verbose (Optional) details given showing error message/warning.  default, controlled support function getEctdVerbose ... zero objects can coerced character     (pasted together separator) single     condition object. immediate. logical, indicating call output     immediately, even getOption(\"warn\") <= 0.","code":""},{"path":"/reference/ectdStop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Error handling functions for the ectd package. — ectdStop","text":"Nothing.","code":""},{"path":"/reference/ectdStop.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Error handling functions for the ectd package. — ectdStop","text":"ectdWarning: Error handling functions ectd package.","code":""},{"path":[]},{"path":"/reference/ectdStop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Error handling functions for the ectd package. — ectdStop","text":"Rich Pugh","code":""},{"path":"/reference/ectdStop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Error handling functions for the ectd package. — ectdStop","text":"","code":"if (FALSE) {      ectdStop(\"something wrong happened\")   }"},{"path":"/reference/generateData.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate simulated data replicates — generateData","title":"Generate simulated data replicates — generateData","text":"Generate Simulated Data Replicates controlling dosing, covariates, parametes, response, missingness interims","code":""},{"path":"/reference/generateData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate simulated data replicates — generateData","text":"","code":"generateData(   replicateN,   subjects = NULL,   treatSubj = subjects,   treatDoses,   treatSeq,   treatType = \"Parallel\",   treatPeriod,   genParNames,   genParMean,   genParVCov = 0,   respEqn,   respName = getEctdColName(\"Response\"),   treatProp,   treatOrder = FALSE,   conCovNames,   conCovMean,   conCovVCov,   conCovCrit = NULL,   conCovDigits = 3,   conCovMaxDraws = 100,   disCovNames,   disCovVals,   disCovProb,   disCovProbArray,   extCovNames,   extCovFile,   extCovSubset,   extCovRefCol,   extCovSameRow = TRUE,   extCovDataId = idCol,   timeCovNames,   timeCovMean,   timeCovVCov,   timeCovCrit = NULL,   genParCrit,   genParBtwNames,   genParBtwMean,   genParBtwVCov,   genParErrStruc = \"None\",   genParMaxDraws = 100,   genParRangeTolerance = 0.5,   extParFile,   extParNames,   extParBtwNames,   extParBtwNums,   extParSubset = NULL,   extParCrit,   extParErrStruc = \"None\",   extParRefColData,   extParRefColName,   extParDataId = idCol,   respInvLink,   respDist = \"Normal\",   respVCov,   respErrStruc = \"Additive\",   respCrit,   respDigits = 3,   mcarProp = 0,   mcarRule,   dropFun,   dropFunExtraArgs = list(),   interimSubj,   interimMethod = \"Sample\",   seed = .deriveFromMasterSeed(),   idCol = getEctdColName(\"Subject\"),   doseCol = getEctdColName(\"Dose\"),   timeCol = getEctdColName(\"Time\"),   trtCol = getEctdColName(\"Trt\"),   parOmitFlag = getEctdColName(\"ParOmit\"),   respOmitFlag = getEctdColName(\"RespOmit\"),   missingFlag = getEctdColName(\"Missing\"),   interimCol = getEctdColName(\"Interim\"),   parBtwSuffix = \".Between\",   deleteCurrData = TRUE,   covDiff = TRUE,   treatDiff = TRUE,   workingPath = getwd() )"},{"path":"/reference/generateData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate simulated data replicates — generateData","text":"replicateN (Required) Number replicates create simulated data subjects (Required) Number subjects simulation treatSubj (Optional) Number subjects allocate treatments, vector allocations treatDoses (Optional) Vector numeric treatment doses.  default, \"subjects\" input treatSeq (Optional) Treatment matrix crossover designs.  Missing default, required treatType set \"Crossover\" treatType (Optional) Treatment type: 'Parallel' 'Crossover'. Default \"Parallel\" treatPeriod (Optional) Vector numeric treatment time points. Missing default, resulting \"time\" element generated data genParNames (Optional) Names fixed effects generate.  Missing default, resulting fixed parameters created genParMean (Optional) Means generating fixed parameters.  Missing default genParVCov (Optional) Covariance matrix generating fixed parameters.  default, matrix zeros respEqn (Required) Formula creating simulated response respName (Optional) Response variable name.  Default \"RESP\" treatProp (Optional) Proportions sampling.  Missing default, resulting unbiased sampling treatOrder (Optional) Logical flag: allocations assigned order.  FALSE default conCovNames (Optional) Continuous covariate names.  Missing default, resulting continuous covariates created conCovMean (Optional) Continuous covariate means.  Missing default conCovVCov (Optional) Continuous covariate covariance matrix. Missing default conCovCrit (Optional) Continuous covariate acceptable range.  Missing default conCovDigits (Optional) Continuous covariate rounding digits.  3 default conCovMaxDraws (Optional) Continuous covariate maximum draws.  100 default disCovNames (Optional) Discrete covariate names.  Missing default, resulting discrete covariates created disCovVals (Optional) Discrete covariate values.  Missing default disCovProb (Optional) Discrete covariate probabilities.  Missing default disCovProbArray (Optional) Array probabilities multivariate sampling.  Missing default extCovNames (Optional) Names continuous covariates.  Missing default, resulting imported covariates extCovFile (Optional) File import (including full relative path).  Missing default extCovSubset (Optional) Subset apply data.  Missing default extCovRefCol (Optional) Reference variable.  Missing default extCovSameRow (Optional) Logical flag: covariates sampled row.  TRUE default extCovDataId (Optional) Subject variable name file.  \"idCol\" default timeCovNames (Optional) Time-varying covariate names.  Missing default, resulting Time-varying covariates created timeCovMean (Optional) Time-varying covariate means.  Missing default timeCovVCov (Optional) Time-varying covariate covariance matrix. Missing default timeCovCrit (Optional) Time-varying covariate acceptable range. Missing default genParCrit (Optional) Range acceptable values generated fixed effects.  Missing default genParBtwNames (Optional) subject effects generate. Missing default, resulting created subject effects genParBtwMean (Optional) Means generated subject effects. Missing default genParBtwVCov (Optional) Covariance matrix generated subject effects.  Missing default genParErrStruc (Optional) Function map generated effects: Additive, Proportional None.  \"None\" default genParMaxDraws (Optional) Maximum number iterations generate valid parameters.  100 default genParRangeTolerance (Optional) Proportion subjects \"range\" parameter data happy proceeding extParFile (Optional) File name external parameter data import.  Missing default, resulting imported parameter variables extParNames (Optional) Names parameters import external file.  Missing default extParBtwNames (Optional) subject effects variables import external file.  Missing default extParBtwNums (Optional) Integer mapping random fixed effects imported parameter data.  Missing default extParSubset (Optional) Subsets applied imported parameter sampling.  Missing default extParCrit (Optional) Acceptance range imported parameter columns extParErrStruc (Optional) Function map effects imported parameter data: Additive, Proportional None.  \"None\" default extParRefColData (Optional) Reference column imported parameter data.  Missing default extParRefColName (Optional) Reference column name imported parameter data.  Missing default extParDataId (Optional) Subject variable name external parameter file.  \"idCol\" default respInvLink (Optional) Inverse link function linear predictor.  Missing default, resulting inverse link applied respDist (Optional) Outcome response variable distribution (\"Normal\" default) respVCov (Optional) Residual error (co)variance apply generated response.  None default respErrStruc (Optional) Function describing apply residual error generated response: Additive, Log-Normal Proportional. \"Additive\" default respCrit (Optional) Range acceptable values created response. Missing (criteria) default respDigits (Optional) Number digits round created response.  3 default mcarProp (Optional) Proportion observations set missing random.  0 default mcarRule (Optional) Rule specify observations data included MCAR allocation.  Missing default dropFun (Optional) User defined function define criteria subject dropout.  Missing (dropout) default dropFunExtraArgs (Optional) Additional arguments dropout function.  None default interimSubj (Optional) Proportion total subjects assigned interim analysis.  Missing default, resulting \"interim\" variable derived interimMethod (Optional) Method creating interim variable: 'Sample' 'Proportion'.  \"Sample\" default seed (Optional) Random seed.  default, derived current session random seed idCol (Optional) Subject variable name (\"SUBJ\" default) doseCol (Optional) Dose variable name (\"DOSE\" default) timeCol (Optional) Time variable name (\"TIME\" default) trtCol (Optional) Treatment variable name (\"TRT\" default) parOmitFlag (Optional) Parameter omit flag name (\"PAROMIT\" default) respOmitFlag (Optional) Response omit flag name (\"RESPOMIT\" default) missingFlag (Optional) Missingness flag name (\"MISSING\" default) interimCol (Optional) Interim variable name (\"INTERIM\" default) parBtwSuffix (Optional) Suffix retained subject effects variables.  Suffix \".\" used default deleteCurrData (Optional) existing data deleted starting generation phase (TRUE default) covDiff (Optional) covariates differ replicates (TRUE default) treatDiff (Optional) treatment allocation differ replicates (TRUE default) workingPath (Optional) Working directory create data. default, current working directory used","code":""},{"path":"/reference/generateData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate simulated data replicates — generateData","text":"value returned generateData function.  However, side effect, number simulated replicate datasets created.","code":""},{"path":"/reference/generateData.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate simulated data replicates — generateData","text":"generateData function calls low level generate data components create sets simulated data.  following components called create aspects simulated trial data: createTreatments: Used create dataset possible treatment regimes allocated subjects allocateTreatments: Use allocate treatments subjects simulated study createCovariates: Creates set fixed covariates simulated population createParameters: Creates simulated fixed subject parameters subjects replicate createResponse: Creates simulated response variable based available derived data createMCAR: Adds simulated \"missing\" flag data createDropout: Adds simulated \"missing\" flag data based dropout function createInterims: Assigns subjects study interim analyses function iteratively builds combines data components replicte, stores data \"ReplicateData\" subdirectory working directory.  data can analyzed using call analyzeData function.","code":""},{"path":[]},{"path":"/reference/generateData.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate simulated data replicates — generateData","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/generateData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate simulated data replicates — generateData","text":"","code":"if (FALSE) { generateData( replicateN = 500, subjects = 400, treatDoses = c(0, 5, 25, 50, 100),   conCovNames = c(\"wt\", \"age\"), conCovMean = c(83, 55) , conCovVCov = c(14,10)^2 ,   conCovDigits = 1, conCovCrit = \"18 <= age <= 65\",   genParNames = \"E0,ED50,EMAX\", genParMean = c(2,50,10), genParVCov = diag( c(.5,30,10) ),   genParBtwNames = \"E0,ED50,EMAX\", genParBtwMean = c(0,0,0), genParBtwVCov = diag(3),   respEqn = \"E0 + ((DOSE * EMAX)/(DOSE + ED50))\",  respVCov = 5,   interimSubj = \".3,.7\") }"},{"path":"/reference/getEctdColName.html","id":null,"dir":"Reference","previous_headings":"","what":"Control of default column names — getEctdColName","title":"Control of default column names — getEctdColName","text":"Functions allow control default column names simulated data","code":""},{"path":"/reference/getEctdColName.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Control of default column names — getEctdColName","text":"","code":"getEctdColName(colName)  setEctdColName(colName, Value)  resetEctdColNames(whichNames = names(getNames))  getEctdPossibleColNames(colName)  setEctdPossibleColNames(colName, Value)  matchEctdColNames(colName, dataNames)"},{"path":"/reference/getEctdColName.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Control of default column names — getEctdColName","text":"colName (Required) \"column type\" variable name interest (one 'Subject', 'Time', 'Dose', 'Interim', 'ParOmit', 'RespOmit', 'Response', 'Trt', 'Missing', 'Replicate', 'DrugName' 'Drug') Value (Required) Value set default column name whichNames Column types reset default name (default ) dataNames (Required) Column names match possible set column names","code":""},{"path":"/reference/getEctdColName.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Control of default column names — getEctdColName","text":"\"getEctdColName\" function returns single character, giving current column name \"getEctdPossibleColNames\" function returns character vector, giving set possible columns \"matchEctdColNames\" function returns single character identifying variable \"dataNames\" used \"colName\" column functions explicitly return anything","code":""},{"path":"/reference/getEctdColName.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Control of default column names — getEctdColName","text":"functions provide following capabilities:   * getEctdColName - Gets current default column name given column   type   * setEctdColName - Sets current default column name column   type   * resetEctdColNames - Resets current default column names    initial state    * getEctdPossibleColNames - Gets set possible column names given column type   * setEctdPossibleColNames - Sets set possible column names given column type   * matchEctdColNames - Selects column name set names best matches possible column type names set possible \"column types\" :   * Subject - Subject column   * Dose - Dose column   * Time - Time column   * Replicate - Replicate column names   * Interim - Interim allocation column name   * ParOmit - Parameter \"omit\" flag column name   * RespOmit - Response \"omit\" flag column name   * Response - Response column name   * Trt - Treatment column name   * Missing - Parameter \"omit\" flag column name   * DrugName - Name column containing \"Drug Name\" (used typical   value simulations)   * Drug - Name column containing \"Drug Value\" (used typical   value simulations)","code":""},{"path":"/reference/getEctdColName.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Control of default column names — getEctdColName","text":"setEctdColName: resetEctdColNames: getEctdPossibleColNames: setEctdPossibleColNames: matchEctdColNames:","code":""},{"path":"/reference/getEctdColName.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Control of default column names — getEctdColName","text":"","code":"if (FALSE) {   getEctdColName(\"Subject\")   setEctdColName(\"Subject\", \"ID\")   getEctdColName(\"Subject\")   resetEctdColNames()   getEctdPossibleColNames(\"Subject\")   matchEctdColNames (\"Subject\", c(\"A\", \"SUBJ\", \"B\")) }"},{"path":"/reference/getReplicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Trial replicates vector — getReplicates","title":"Trial replicates vector — getReplicates","text":"Get vector available trial replicates, based specified data storage method","code":""},{"path":"/reference/getReplicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trial replicates vector — getReplicates","text":"","code":"getReplicates(   path = \"ReplicateData\",   prefix = \"replicate\",   method = getEctdDataMethod(),   workingPath = getwd() )"},{"path":"/reference/getReplicates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trial replicates vector — getReplicates","text":"path subdirectory (within \"workingPath\") containing replicates files ('CSV' 'RData' methods ) prefix Prefix used looking simulated data files method Data storage method use, either \"CSV\", \"RData\" \"Internal (given getEctdDataMethod default) workingPath Root path simulated data (default working directory)","code":""},{"path":"/reference/getReplicates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trial replicates vector — getReplicates","text":"numeric vector replicate values","code":""},{"path":"/reference/getReplicates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Trial replicates vector — getReplicates","text":"function looks existing replicates based method, directories file prefix given. method \"CSV\", function looks files starting \"prefix\" ending \".csv\" within \"path\" subdirectory \"workingPath\" Similarly, method \"RData\", function looks files starting \"prefix\" ending \".rdata\" location method \"Internal\", function looks data frames found internal data storage location (.ectdEnv$DataStore) function return vector replicate numbers, fail replicates found","code":""},{"path":"/reference/getReplicates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Trial replicates vector — getReplicates","text":"","code":"if (FALSE) {    getReplicates()   }"},{"path":"/reference/initialChar.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert the first letter that occurs in a string to lower case — initialChar","title":"Convert the first letter that occurs in a string to lower case — initialChar","text":"default, initialChar finds first letter occurs string returns lower case version.  user may use \"adm\" argument restrict admissable letters may returned (default possible lower case letters).","code":""},{"path":"/reference/initialChar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert the first letter that occurs in a string to lower case — initialChar","text":"","code":"initialChar(txt, adm = \"[:lower:]\", err = \"Not acceptable value\")"},{"path":"/reference/initialChar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert the first letter that occurs in a string to lower case — initialChar","text":"txt (Required) string input process adm (Optional) Regular expression may used restrict set letters returned.  default allow lower case letters err (Optional) error message printed admissable letters (determined adm) found.  default, message \"acceptable value\" displayed","code":""},{"path":"/reference/initialChar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert the first letter that occurs in a string to lower case — initialChar","text":"initalChar returns lower case version first letter contained string \"txt\" character admissable.  (letter found), error message printed.","code":""},{"path":"/reference/initialChar.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Convert the first letter that occurs in a string to lower case — initialChar","text":"function case sensitive.","code":""},{"path":"/reference/initialChar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert the first letter that occurs in a string to lower case — initialChar","text":"Romain Francois","code":""},{"path":"/reference/initialChar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert the first letter that occurs in a string to lower case — initialChar","text":"","code":"initialChar(\"100 Kilometers\") #> [1] \"k\" if (FALSE) {    # The first character is \"A\", but \"a\" is not in the list of admissable letters     initialChar(\"Allen, Alistair, Atticus\", adm = \"irt\" )   }"},{"path":"/reference/interimAnalysis.html","id":null,"dir":"Reference","previous_headings":"","what":"interim Analysis — interimAnalysis","title":"interim Analysis — interimAnalysis","text":"function runs interimCode takes decisions dose drop next interim step, decision take can also potentially stop analysis interim stage.","code":""},{"path":"/reference/interimAnalysis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"interim Analysis — interimAnalysis","text":"","code":"interimAnalysis(data, interimCode, uniqueDoses = NULL)"},{"path":"/reference/interimAnalysis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"interim Analysis — interimAnalysis","text":"data (Required) Dataset analyze interimCode (Required) Function execute data produce list structure described uniqueDoses Unique study doses","code":""},{"path":"/reference/interimAnalysis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"interim Analysis — interimAnalysis","text":"output interim code R \"list\" structure. empty list returned, signifies instructions apply following interim analysis (ie. stop trial drop doses) return list contains \"STOP\" element, \"STOP\" element logical value length 1, used determine whether trial stopped interim. return list contains \"DROP\" element, \"DROP\" element vector dose values, used determine doses drop next interim. list elements \"DROP\" \"STOP\" ignored.","code":""},{"path":"/reference/interimAnalysis.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"interim Analysis — interimAnalysis","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/interimAnalysis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"interim Analysis — interimAnalysis","text":"","code":"myData <- data.frame(DOSE=c(0, 15, 30), TEST = 1:3)   myFun <- function(data) {     outList <- list()     outList$STOP <- any(data$TEST) > 5     myTest <- data$TEST > 2     if (any(myTest)) outList$DROP <- data$DOSE[myTest]     outList   }   interimAnalysis(myData, myFun ) #> $STOP #> [1] FALSE #>  #> $DROP #> [1] 30 #>"},{"path":"/reference/macroEvaluation.html","id":null,"dir":"Reference","previous_headings":"","what":"Macro Evaluation — macroEvaluation","title":"Macro Evaluation — macroEvaluation","text":"macro evaluation gives short summary analysis performed single replicate data.","code":""},{"path":"/reference/macroEvaluation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Macro Evaluation — macroEvaluation","text":"","code":"macroEvaluation(   data,   macroCode,   interimCol = getEctdColName(\"Interim\"),   doseCol = getEctdColName(\"Dose\") )"},{"path":"/reference/macroEvaluation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Macro Evaluation — macroEvaluation","text":"data (Required) Data set use, typically returned micro evaluation step. macroCode (Required) Function used summarize micro data.  function arguments \"doseCol\" /\"interimCol\", arguments macroEvaluation passed addition data interimCol (Optional) Name interim column, valid name (\"INTERIM\" default). See validNames doseCol (Optional) Name dose column, valid name (\"DOSE\" default). See validNames","code":""},{"path":"/reference/macroEvaluation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Macro Evaluation — macroEvaluation","text":"data frame complies checkMacroFormat","code":""},{"path":"/reference/macroEvaluation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Macro Evaluation — macroEvaluation","text":"macro code first studied make sure function takes data argument.  code executed micro data, produce data frame containing single row. checked using checkMacroFormat function.","code":""},{"path":"/reference/macroEvaluation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Macro Evaluation — macroEvaluation","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/macroEvaluation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Macro Evaluation — macroEvaluation","text":"","code":"# example of micro data with interim   microData <- get0(\"microData\", envir = asNamespace(\"MSToolkit\"))   mCode <- function(data) {     diffMeans <- data$MEAN[data$DOSE == 100 & data$INTERIM == 0] -     data$MEAN[data$DOSE == 0 & data$INTERIM == 0]     data.frame(SUCCESS = diffMeans > 10, NFINAL = sum(data$N))   }   out <- macroEvaluation(microData, mCode)   stopifnot( nrow(out) == 1 )"},{"path":"/reference/parseCharInput.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a comma seperated string — parseCharInput","title":"Parse a comma seperated string — parseCharInput","text":"\"parseCharInput\" function converts comma-seperated string vector splitting string along commas.  \"convertToNumeric\" true, elements string converted numbers numeric vector returned.","code":""},{"path":"/reference/parseCharInput.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a comma seperated string — parseCharInput","text":"","code":"parseCharInput(   input,   convertToNumeric = TRUE,   sort = FALSE,   expected,   msg = \"wrong length\",   checkdup = FALSE,   missingMsg = \"Unknown\",   checkProb = FALSE,   valid = FALSE )"},{"path":"/reference/parseCharInput.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a comma seperated string — parseCharInput","text":"input (Required) string processed convertToNumeric (Optional) logical value.  input converted numerics?  TRUE default sort (Optional) logical value.  resulting vector sorted.  FALSE default expected (Optional) expected length output vector.  check performed default msg (Optional) Error message print input correct length specified \"expected\".  Default \"Wrong length\" checkdup (Optional) logical value. error generated duplicated value?  FALSE default missingMsg (Optional) Error message print input missing. Default \"Unknown\" checkProb (Optional) logical value.  function check output vector sums one?  FALSE default valid (Optional) logical value. validNames function used check validity extracted names?  FALSE default","code":""},{"path":"/reference/parseCharInput.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a comma seperated string — parseCharInput","text":"numeric vector character vector depending convertToNumeric flag.","code":""},{"path":[]},{"path":"/reference/parseCharInput.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parse a comma seperated string — parseCharInput","text":"Romain Francois","code":""},{"path":"/reference/parseCharInput.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse a comma seperated string — parseCharInput","text":"","code":"parseCharInput( \"1,2,4\") #> Error in parseCharInput(\"1,2,4\"): could not find function \"parseCharInput\"   parseCharInput( \"1,6,4\", sort = TRUE ) #> Error in parseCharInput(\"1,6,4\", sort = TRUE): could not find function \"parseCharInput\"    if (FALSE) {   ## see also the unit tests for more examples   file.show( system.file( \"Runit\", \"runit.supportfunctions.R\" ,     package = \"MSToolkit\"))   }"},{"path":"/reference/parseCovMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a covariance matrix — parseCovMatrix","title":"Parse a covariance matrix — parseCovMatrix","text":"Creates symmetric positive definite matrix vector possible, checks given matrix symmetric positive definite.","code":""},{"path":"/reference/parseCovMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a covariance matrix — parseCovMatrix","text":"","code":"parseCovMatrix(values, nCov, tol = 1e-06)"},{"path":"/reference/parseCovMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a covariance matrix — parseCovMatrix","text":"values (Required) Either matrix mixed character-numeric vector nCov (Required) number rows columns available resulting matrix tol (Optional) Numerical tolerance positive-definiteness check.  default, tolerance used 1e-06","code":""},{"path":"/reference/parseCovMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a covariance matrix — parseCovMatrix","text":"positive definite symmetric matrix","code":""},{"path":"/reference/parseCovMatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse a covariance matrix — parseCovMatrix","text":"parseCovMatrix attempts create symmetric positive definite matrix dimension nCov x nCov. values matrix, parseCovMatrix simply check symmetric positive definite tolerance inidicated tol. numeric vector, parseCovMatrix try create nCov x nCov positive definite symmetric matrix, method creation depending values nCov.  values contains single entry, nCov x nCov diagonal matrix single value repeated nCov times created.  number entries \"values\" equal \"nCov\", parseCovMatrix create diagonal matrix whose diagonal equal \"values\".  number entries \"values\" equal nCov * (nCov+1) / 2, parseCovMatrix create positive definite symmetric matrix entries lower triangle taken \"values\".  none conditions hold entries \"values\" compatible positive definite symmetric matrices, error printed.","code":""},{"path":[]},{"path":"/reference/parseCovMatrix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parse a covariance matrix — parseCovMatrix","text":"Romain Francois","code":""},{"path":"/reference/parseCovMatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse a covariance matrix — parseCovMatrix","text":"","code":"parseCovMatrix(2, nCov = 3) #> Error in parseCovMatrix(2, nCov = 3): could not find function \"parseCovMatrix\"   parseCovMatrix(c(1,2,3), nCov = 3) #> Error in parseCovMatrix(c(1, 2, 3), nCov = 3): could not find function \"parseCovMatrix\"   parseCovMatrix(c(1,2,4), nCov = 2) #> Error in parseCovMatrix(c(1, 2, 4), nCov = 2): could not find function \"parseCovMatrix\""},{"path":"/reference/parseHashString.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a string seperated by hash symbols or a vector (or list) of strings\nnot containing any hash symbols — parseHashString","title":"Process a string seperated by hash symbols or a vector (or list) of strings\nnot containing any hash symbols — parseHashString","text":"parseHashString constructs list numerical vectors single string stores vectors comma separated substrings delimited hash symbols.  Alternatively passed list vector strings comma-separated list numbers, produce list numerical vectors processing strings parseCharInput","code":""},{"path":"/reference/parseHashString.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a string seperated by hash symbols or a vector (or list) of strings\nnot containing any hash symbols — parseHashString","text":"","code":"parseHashString(input, ..., missingMsg)"},{"path":"/reference/parseHashString.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a string seperated by hash symbols or a vector (or list) of strings\nnot containing any hash symbols — parseHashString","text":"input (Required) string process ... (Optional) Additional arguments pass parseCharInput.  additional arguments passed default missingMsg (Optional) Message display input provided.  standard message displayed default","code":""},{"path":"/reference/parseHashString.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a string seperated by hash symbols or a vector (or list) of strings\nnot containing any hash symbols — parseHashString","text":"list numerical vectors.","code":""},{"path":"/reference/parseHashString.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Process a string seperated by hash symbols or a vector (or list) of strings\nnot containing any hash symbols — parseHashString","text":"parseHashString one four things depending arguments passed : (1) input single string composed commas, numbers hash symbols, split string along hash symbols process resulting strings parseCharInput.  result list numerical vectors.  example, parseHashString(\"1,2\\#3,4\") create list elements c(1,2) c(3,4). (2) input vector strings hash symbols, simply apply parseCharInput element vector construct list result.  Thus list created previous example also created calling parseHashString(c(\"1,2\", \"3,4\"). (3) input list character strings, functions essentially (2). (4) input list numerical vectors, returns input without modification.","code":""},{"path":[]},{"path":"/reference/parseHashString.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Process a string seperated by hash symbols or a vector (or list) of strings\nnot containing any hash symbols — parseHashString","text":"Romain Francois","code":""},{"path":"/reference/parseHashString.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process a string seperated by hash symbols or a vector (or list) of strings\nnot containing any hash symbols — parseHashString","text":"","code":"parseHashString(\"1.5, 2, 3.2#5, 4.2#10,11\") #> Error in parseHashString(\"1.5, 2, 3.2#5, 4.2#10,11\"): could not find function \"parseHashString\" parseHashString(c(\"1.5, 2, 3.2\",\"5, 4.2\",\"10,11\")) #> Error in parseHashString(c(\"1.5, 2, 3.2\", \"5, 4.2\", \"10,11\")): could not find function \"parseHashString\" parseHashString(list(\"1.5, 2, 3.2\",\"5, 4.2\",\"10,11\")) #> Error in parseHashString(list(\"1.5, 2, 3.2\", \"5, 4.2\", \"10,11\")): could not find function \"parseHashString\""},{"path":"/reference/parseRCode.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse R Code — parseRCode","title":"Parse R Code — parseRCode","text":"Parses character string ensure valid R code, returning R \"expression\" object","code":""},{"path":"/reference/parseRCode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse R Code — parseRCode","text":"","code":"parseRCode(code)"},{"path":"/reference/parseRCode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse R Code — parseRCode","text":"code Character string containing R Code parse","code":""},{"path":"/reference/parseRCode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse R Code — parseRCode","text":"expression object","code":""},{"path":"/reference/parseRCode.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse R Code — parseRCode","text":"parseRCode function wraps \"parse\" checks ensure valid expression created","code":""},{"path":"/reference/parseRCode.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parse R Code — parseRCode","text":"Romain Francois, Rich Pugh","code":""},{"path":"/reference/parseRangeCode.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse a numerical range expression — parseRangeCode","title":"Parse a numerical range expression — parseRangeCode","text":"parseRangeCode: Converts inequalities two comparators stored vector strings executable R expression.  instance, parseRangeCode(c(\"1 < Y < 20\", \"40 < Y\")) yield expression (1<Y)&(Y<20)&(40<Y).  parseRCode: simply parse R string expression.","code":""},{"path":"/reference/parseRangeCode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse a numerical range expression — parseRangeCode","text":"","code":"parseRangeCode(code)"},{"path":"/reference/parseRangeCode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse a numerical range expression — parseRangeCode","text":"code (Required) parseRangeCode: vector strings contain inequalities along various seperators (see ).  inequality either 1 2 comparators. parseRCode: code string. parseRCode character vector containing code.","code":""},{"path":"/reference/parseRangeCode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse a numerical range expression — parseRangeCode","text":"expression constructed detailed .","code":""},{"path":"/reference/parseRangeCode.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse a numerical range expression — parseRangeCode","text":"parseRangeCode function converts various kinds ranges/inequalities normally handled R R-executable expressions.  instance convert inequalities form \"< B < C\" (< B) & (B < C), < may replaced comparator. Moreover allows inqualities concatenated symbols \"&\", \";\" \",\" treated equivalent logical \"\" (.e. \"&\"). Thus \"< B <C & D > E, F <= G\" converted (< B)&(B < C)&(D > E)&(F <= G). addition code vector one element, element parsed concatenated single expression \"&\".  Hence c(\"1 < Y\", \"2 < Z <= 5\") become (1 < Y)&(2 < Z)&(Z <= 5).","code":""},{"path":"/reference/parseRangeCode.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Parse a numerical range expression — parseRangeCode","text":"character \"|\" allowed expressions contained \"code\" parseRangeCode function.","code":""},{"path":[]},{"path":"/reference/parseRangeCode.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parse a numerical range expression — parseRangeCode","text":"Romain Francois","code":""},{"path":"/reference/parseRangeCode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse a numerical range expression — parseRangeCode","text":"","code":"# Examples of using subsets exData <- data.frame( Y = rnorm(200), B = rnorm( 200 ) ) subs1 <- parseRangeCode(\"1 < Y < 10 & 1 > B > -2\") #> Error in parseRangeCode(\"1 < Y < 10 & 1 > B > -2\"): could not find function \"parseRangeCode\" exData[ eval(subs1, exData), ] #> Error in eval(subs1, exData): object 'subs1' not found  subs2 <- parseRangeCode(c(\"1 < Y < 10\", \"1 > B > -2\")) #> Error in parseRangeCode(c(\"1 < Y < 10\", \"1 > B > -2\")): could not find function \"parseRangeCode\" exData[ eval(subs1, exData), ] #> Error in eval(subs1, exData): object 'subs1' not found  expr <- parseRCode(\"rnorm(30)\") #> Error in parseRCode(\"rnorm(30)\"): could not find function \"parseRCode\" eval( expr ) #> Error in eval(expr): object 'expr' not found"},{"path":"/reference/performAnalysis.html","id":null,"dir":"Reference","previous_headings":"","what":"Runs the analysis code against one dataset — performAnalysis","title":"Runs the analysis code against one dataset — performAnalysis","text":"function iteratively called analyzeRep analyze replicate dataset step defined interims.","code":""},{"path":"/reference/performAnalysis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Runs the analysis code against one dataset — performAnalysis","text":"","code":"performAnalysis(   analysisCode,   doses,   data,   software = c(\"R\", \"SAS\"),   includeRows = NULL,   interimCol = getEctdColName(\"Interim\"),   doseCol = getEctdColName(\"Dose\"),   seed = .deriveFromMasterSeed(),   workingPath = getwd(),   cleanUp = TRUE,   tempSasDir = tempdir() )"},{"path":"/reference/performAnalysis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Runs the analysis code against one dataset — performAnalysis","text":"analysisCode (Required) Analysis code: R function, reference external R script, reference external SAS script doses (Required) Vector doses estimates expected data (Required) Input dataset perform analysis software (Optional) Software analysis: \"R\" \"SAS\" (default \"R\") includeRows (Optional) 2 column matrix specifying interims doses include analysis.  default, subsets applied interimCol Interim flag column name doseCol Dose column name seed (Optional) Random number generation seed.  default, derived current random seed workingPath (Optional) Working directory analysis.  default current working directory cleanUp (Optional) Logical: remove files passed SAS? tempSasDir Temporary Sas Directory","code":""},{"path":"/reference/performAnalysis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Runs the analysis code against one dataset — performAnalysis","text":"function output valid \"Micro Evaluation\" data structure specified checkMicroFormat help file.","code":""},{"path":"/reference/performAnalysis.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Runs the analysis code against one dataset — performAnalysis","text":"function tries perform analysis contained analysisCode data.  analysis code specified either external file containing code (SAS R), R function (R ). software set \"SAS\" analysis code assumed reference external SAS script.  SAS code must accept single dataset called work.infile, create output dataset called work.outfile.  work.outfile dataset must valid \"Micro Evaluation\" structure specified help file checkMicroFormat.  software \"R\", analysis code input must either R function R script.  R analysis code must also return valid \"Micro Evaluatoin\" structure specified function checkMicroFormat","code":""},{"path":[]},{"path":"/reference/performAnalysis.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Runs the analysis code against one dataset — performAnalysis","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/performAnalysis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Runs the analysis code against one dataset — performAnalysis","text":"","code":"if (FALSE) {    # Emax example   anaCode <- function(data){     with( data, {       uniDoses <- sort( unique(DOSE))       outDf <- data.frame( DOSE = uniDoses,         MEAN = tapply(RESP, DOSE, mean) ,         SE   = tapply(RESP, DOSE, sd )  )       outDf$LOWER <- outDf$MEAN - 2 * outDf$SE       outDf$UPPER <- outDf$MEAN + 2 * outDf$SE       outDf$N     <- table(DOSE)[ as.character(uniDoses) ]       outDf     })   }    # example data   exData <- system.file( \"Runit\", \"data\", \"analyseRep\", \"ReplicateData\", \"replicate0001.csv\",   package = \"MSToolkit\")   out <- performAnalysis(anaCode, data = exData, doses = c(0, 5, 25, 50, 100) )   checkMicroFormat( out )       # Check the format of the return structure  }"},{"path":"/reference/readAllData.html","id":null,"dir":"Reference","previous_headings":"","what":"Read scenario data — readAllData","title":"Read scenario data — readAllData","text":"Reads single element replicate, macro evaluation micro evaluation data current scenario","code":""},{"path":"/reference/readAllData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read scenario data — readAllData","text":"","code":"readAllData(   dataType = c(\"ReplicateData\", \"MicroEvaluation\", \"MacroEvaluation\"),   workingPath = getwd(),   dirName = dataType,   prefix = switch(dataType, ReplicateData = \"replicate\", MicroEvaluation = \"micro\",     MacroEvaluation = \"macro\"),   replicates = NULL,   consolidate = TRUE,   replicateCol = getEctdColName(\"Replicate\"),   method = getEctdDataMethod() )"},{"path":"/reference/readAllData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read scenario data — readAllData","text":"dataType (Optional) type data wish read - either \"ReplicateData\", \"MacroEvaluation\" \"MicroEvaluation\".  Default \"ReplicateData\" workingPath (Optional) working path current scenario.  current working directory used default. dirName (Optional) Subdirectory workingPath read data.  default, taken \"dataType\" input prefix (Optional) Prefix file name use (eg. \"micro\" Micro Evaluation files).  Default \"Replicate\" dataType \"ReplicateData\", \"Micro\" dataType \"MicroEvaluation\" \"Macro\" dataType \"MacroEvaluation\" replicates (Optional) vector identifying subset replicates import directory.  default, replicates imported consolidate (Optional) function combine seperate data frames single data frame.  TRUE default replicateCol (Optional) Name created \"Replicate\" variable consolidated data frame (default given getEctdColName) method (Optional) Data storage method (.e. extract data ).  Given getEctdDataMethod default","code":""},{"path":"/reference/readAllData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read scenario data — readAllData","text":"consolidate FALSE, function return list data frames.  consolidate TRUE, function combine list single data frame return","code":""},{"path":[]},{"path":"/reference/readAllData.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read scenario data — readAllData","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/readAllData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read scenario data — readAllData","text":"","code":"if (FALSE) {    readAllData(dataType = \"Macro\", consolidate = FALSE)    readAllData(dataType = \"Micro\")  }"},{"path":"/reference/readData.html","id":null,"dir":"Reference","previous_headings":"","what":"Read scenario data — readData","title":"Read scenario data — readData","text":"Reads single element replicate, macro evaluation micro evaluation data current scenario","code":""},{"path":"/reference/readData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read scenario data — readData","text":"","code":"readData(   dataNumber,   dataType = c(\"ReplicateData\", \"MicroEvaluation\", \"MacroEvaluation\"),   variables = NULL,   workingPath = getwd(),   method = getEctdDataMethod() )"},{"path":"/reference/readData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read scenario data — readData","text":"dataNumber (Required) number data entry wish read. number must 0 9999 dataType (Optional) type data wish read - either \"ReplicateData\", \"MacroEvaluation\" \"MicroEvaluation\".  default, \"ReplicateData\" used variables (Optional) variables must data continue.  variables provided default (variable check performed) workingPath (Optional) working path current scenario.  default, current working directory used method (Optional) Data storage method (.e. extract data ).  Given getEctdDataMethod default","code":""},{"path":"/reference/readData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read scenario data — readData","text":"readData return data frame containing desired element data exists.","code":""},{"path":[]},{"path":"/reference/readData.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read scenario data — readData","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/readData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read scenario data — readData","text":"","code":"if (FALSE) {    readData(dataNumber = 10, dataType = \"Macro\")    readData(dataNumber = 1, dataType = \"Replicate\")    readData(dataNumber = 800, dataType = \"Micro\")  }"},{"path":"/reference/removeDirectories.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove directories — removeDirectories","title":"Remove directories — removeDirectories","text":"function removes directories containing data current scenario.","code":""},{"path":"/reference/removeDirectories.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove directories — removeDirectories","text":"","code":"removeDirectories(   dirNames = c(\"ReplicateData\", \"MicroEvaluation\", \"MacroEvaluation\"),   workingPath = getwd(),   method = getEctdDataMethod() )"},{"path":"/reference/removeDirectories.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove directories — removeDirectories","text":"dirNames (Optional) vector directories remove \"workingPath\" directory.  Default remove \"ReplicateData\", \"MicroEvaluation\" \"MacroEvaluation\" directories workingPath (Optional) working directory remove directories.  default, directories removed current working directory method Data storage method (given getEctdDataMethod default)","code":""},{"path":"/reference/removeDirectories.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove directories — removeDirectories","text":"logical vector length dirNames, indicating whether corresponding directories successfully removed","code":""},{"path":"/reference/removeDirectories.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Remove directories — removeDirectories","text":"dirNames must character vector.  function attempt remove directories identified dirNames vector within \"workingPath\" directory method \"Internal\", DataStore emptied directories modified","code":""},{"path":"/reference/removeDirectories.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Remove directories — removeDirectories","text":"Francisco Gochez","code":""},{"path":"/reference/removeDirectories.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove directories — removeDirectories","text":"","code":"if (FALSE) {     createDirectories(dirNames = c(\"ReplicateData\", \"MicroEvaluation\"))     removeDirectories(dirNames = c(\"ReplicateData\", \"MicroEvaluation\"))   }"},{"path":"/reference/setEctdDataMethod.html","id":null,"dir":"Reference","previous_headings":"","what":"Current data storage method — setEctdDataMethod","title":"Current data storage method — setEctdDataMethod","text":"Gets sets current \"data storage\" method, used storage simulated trial data","code":""},{"path":"/reference/setEctdDataMethod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Current data storage method — setEctdDataMethod","text":"","code":"setEctdDataMethod(method)"},{"path":"/reference/setEctdDataMethod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Current data storage method — setEctdDataMethod","text":"method (Required) data storage method use (either 'CSV', 'RData' 'Internal'","code":""},{"path":"/reference/setEctdDataMethod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Current data storage method — setEctdDataMethod","text":"\"getEctdDataMethod\" function returns current data method (\"CSV\", \"RData\" \"Internal\") \"setEctdDataMethod\" function invisibly returns method just set default","code":""},{"path":"/reference/setEctdDataMethod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Current data storage method — setEctdDataMethod","text":"Gets (getEctdDataMethod) sets (setEctdDataMethod) current \"data storage\" method, used storage simulated trial data. choices storage method : * CSV - Replicate data stored seperate CSV files outside R * RData - Replicate data stored seperate RData files outside R * Internal - Replicate data stored list data frames internal environment (.ectdEnv$DataStore) Note: data storage impacts replicate data - micro macro evaluation data always held CSV files","code":""},{"path":"/reference/setEctdDataMethod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Current data storage method — setEctdDataMethod","text":"","code":"if (FALSE) {    nowMethod <- getEctdDataMethod()    setEctdDataMethod(\"CSV\")   getEctdDataMethod()    setEctdDataMethod(\"RData\")   getEctdDataMethod()    setEctdDataMethod(\"Internal\")   getEctdDataMethod()    setEctdDataMethod(nowMethod)  }"},{"path":"/reference/setEctdExternalPath.html","id":null,"dir":"Reference","previous_headings":"","what":"Controls paths to a set of external execution paths — setEctdExternalPath","title":"Controls paths to a set of external execution paths — setEctdExternalPath","text":"Gets sets paths external","code":""},{"path":"/reference/setEctdExternalPath.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Controls paths to a set of external execution paths — setEctdExternalPath","text":"","code":"setEctdExternalPath(pathName, Value)"},{"path":"/reference/setEctdExternalPath.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Controls paths to a set of external execution paths — setEctdExternalPath","text":"pathName Name path return set.  using getEctdExternalPath, leave pathName blank return vector available path names Value New value path","code":""},{"path":"/reference/setEctdExternalPath.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Controls paths to a set of external execution paths — setEctdExternalPath","text":"\"getEctdExternalPath\" function returns current execution path given \"pathName\" \"setEctdExternalPath\" function invisibly returns updated path list","code":""},{"path":"/reference/setEctdExternalPath.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Controls paths to a set of external execution paths — setEctdExternalPath","text":"getEctdExternalPath gets execution path specific application particular environment setEctdExternalPath sets execution path application permanent changes can made modifying \"ECTD.ini\" file library root","code":""},{"path":"/reference/setEctdExternalPath.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Controls paths to a set of external execution paths — setEctdExternalPath","text":"","code":"if (FALSE) {    getEctdExternalPath()    # Look at available paths    getEctdExternalPath(\"SASPATH_WIN\")    # Get the \"SAS Execution on Windows\" path  }"},{"path":"/reference/setEctdVerbose.html","id":null,"dir":"Reference","previous_headings":"","what":"MSToolkit package options — setEctdVerbose","title":"MSToolkit package options — setEctdVerbose","text":"Options used MSToolkit package control logfile, amount messages written logfile, format date.","code":""},{"path":"/reference/setEctdVerbose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MSToolkit package options — setEctdVerbose","text":"","code":"setEctdVerbose(verbose)"},{"path":"/reference/setEctdVerbose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MSToolkit package options — setEctdVerbose","text":"verbose (Required) logical value.  set TRUE, messages sent logfile process generating data analyzing . Set TRUE attaching package.","code":""},{"path":"/reference/setEctdVerbose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MSToolkit package options — setEctdVerbose","text":"function (invisibly) returns previous value arguments.","code":""},{"path":"/reference/setEctdVerbose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"MSToolkit package options — setEctdVerbose","text":"three function write read information (exported) environment .ectdEnv.  settings mainly used (exported) .log function.","code":""},{"path":[]},{"path":"/reference/setEctdVerbose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MSToolkit package options — setEctdVerbose","text":"","code":"if (FALSE) {   oldverb <- setEctdVerbose( TRUE )   olddf   <- setEctdDateFormat(\"%Y\")   oldlf   <- setEctdLogFile(\"mstoolkit.log\")    for( i in 1:100 ) {     MSToolkit:::.log( paste(\"some message:\", i) )   }   file.show( getEctdLogFile() )    setEctdVerbose   (oldverb)   setEctdDateFormat(olddf  )   setEctdLogFile   (oldlf  )  }"},{"path":"/reference/summarizeTrialMeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Trial Mean Data — summarizeTrialMeans","title":"Summarize Trial Mean Data — summarizeTrialMeans","text":"Summarize simulated trial mean responses","code":""},{"path":"/reference/summarizeTrialMeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Trial Mean Data — summarizeTrialMeans","text":"","code":"summarizeTrialMeans(   data,   respCol = getEctdColName(\"Response\"),   bVar = getEctdColName(\"Dose\"),   alpha = 95,   digits = 3,   method = \"Quantile\" )"},{"path":"/reference/summarizeTrialMeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Trial Mean Data — summarizeTrialMeans","text":"data Simulated data summarize (data frame) respCol Response column names (given getEctdColName default) bVar Variables summary produced (\"Dose\" default) alpha Alpha value calculation lower upper intervals (default 95) digits Number digits round summary data method Method use calculating lower/upper intervals: Quantile Gaussian","code":""},{"path":"/reference/summarizeTrialMeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Trial Mean Data — summarizeTrialMeans","text":"data frame containing response summaries","code":""},{"path":"/reference/summarizeTrialMeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize Trial Mean Data — summarizeTrialMeans","text":"input data checked, \"alpha\" value parsed using checkSimAlpha Response means, medians, minima, maxima \"number non-missing values\" calculated \"\" variables (bVar) Lower upper alpha% intervals calculated using either \"Gaussian\" \"Quantile\" method","code":""},{"path":"/reference/summarizeTrialMeans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summarize Trial Mean Data — summarizeTrialMeans","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/validNames.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a character string is a valid R variable name — validNames","title":"Check if a character string is a valid R variable name — validNames","text":"Checks character string valid R variable name using regular expressions.","code":""},{"path":"/reference/validNames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a character string is a valid R variable name — validNames","text":"","code":"validNames(...)"},{"path":"/reference/validNames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a character string is a valid R variable name — validNames","text":"... (Required) collection character vectors checked","code":""},{"path":"/reference/validNames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a character string is a valid R variable name — validNames","text":"None. function simply generates error invalid name passed .","code":""},{"path":"/reference/validNames.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check if a character string is a valid R variable name — validNames","text":"valid R name starts letter dot followed non-numerical character contains letters, numbers dots.","code":""},{"path":"/reference/validNames.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check if a character string is a valid R variable name — validNames","text":"Romain Francois","code":""},{"path":"/reference/validNames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if a character string is a valid R variable name — validNames","text":"","code":"# correct name   validNames(\"DOSE\") #> [1] TRUE   if (FALSE) {     # wrong name     validNames(\".334fsedqw\")   }"},{"path":"/reference/writeData.html","id":null,"dir":"Reference","previous_headings":"","what":"Write scenario data — writeData","title":"Write scenario data — writeData","text":"Writes single element scenario data (replicate, micro evaluation macro evaluation) file.","code":""},{"path":"/reference/writeData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write scenario data — writeData","text":"","code":"writeData(   dat,   dataNumber,   dataType = c(\"ReplicateData\", \"MacroEvaluation\", \"MicroEvaluation\"),   workingPath = getwd(),   append = FALSE,   prefix = switch(dataType, ReplicateData = \"replicate\", MicroEvaluation = \"micro\",     MacroEvaluation = \"macro\"),   method = getEctdDataMethod() )"},{"path":"/reference/writeData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write scenario data — writeData","text":"dat (Required) data frame containing data written dataNumber (Required) entry number data - must whole number 1 9999 dataType (Optional) type data written - must either \"MacroEvaluation\" \"MicroEvaluation\" \"ReplicateData\" (default \"ReplicateData\") workingPath (Optional) path current scenario.  working directory used default append (Optional) logical value.  file entry data specifying already exists, setting append TRUE cause writeData append end file.  Otherwise overwrite file.  default FALSE prefix (Optional) Prefix exported file name method (Optional) Data storage method (.e. extract data ).  Given getEctdDataMethod default","code":""},{"path":"/reference/writeData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write scenario data — writeData","text":"Returns TRUE file successfully created","code":""},{"path":[]},{"path":"/reference/writeData.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Write scenario data — writeData","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/writeData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write scenario data — writeData","text":"","code":"if (FALSE) {     createDirectories()     x <- matrix(data =     c(0,0,0,0,0,4,4,4,4,4,0,10,25,50,100,0.76,16.91,33.12,49.39,65.73,0.21,1.3,2.44,2.33,4.55,     -6.96,9.19,25.4,41.67,58,8.48,24.63,40.84,57.12,73.45,50,50,50,50,50,0,0,0,0,0,0,0,0,0,0),     nrow = 5, ncol = 10)     x <- as.data.frame(x)     colnames(x) <- c(\"INTERIM\",\"INTERIMC\",\"D\",\"MEAN\",\"SE\",\"LOWER\",\"UPPER\",\"N\",\"DROPPED\",     \"STOPPED\")     writeData(dat = x, dataNumber = 199, dataType = \"Micro\")      x <- as.data.frame(matrix(c(0,1),ncol=2,nrow=1))     colnames(x) <- c(\"Dropped\", \"Stopped\")     writeData(dat = x, dataNumber = 5, dataType = \"Macro\")   }"},{"path":"/reference/writeLogFile.html","id":null,"dir":"Reference","previous_headings":"","what":"Write a job log file — writeLogFile","title":"Write a job log file — writeLogFile","text":"Writes log file status jobs currently executing grid.  jobs done, log indicate ran successfully .  , log file show amount time jobs running, along number jobs status.","code":""},{"path":"/reference/writeLogFile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write a job log file — writeLogFile","text":"","code":"writeLogFile(   jobStatuses,   startingTime,   logFileName = \"jobstatus.log\",   statusNames = c(\"PEND\", \"RUN\", \"DONE\", \"EXIT\", \"SUSPEND\", \"UNKWN\"),   workingPath = getwd() )"},{"path":"/reference/writeLogFile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write a job log file — writeLogFile","text":"jobStatuses (Required) vector strings statuses currently running jobs startingTime (Required) time jobs started running logFileName (Optional) Name file write (\"jobstatus.log\" default) statusNames (Optional) vector strings contain possible names statuses jobs .  default, \"PEND\", \"RUN\", \"DONE\", \"EXIT\", \"SUSPEND\" \"UNKWN\" workingPath (Optional) working directory create log file.  default, current working directory used","code":""},{"path":"/reference/writeLogFile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write a job log file — writeLogFile","text":"None.","code":""},{"path":"/reference/writeLogFile.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Write a job log file — writeLogFile","text":"Mike K Smith mstoolkit@googlemail.com","code":""},{"path":"/reference/writeLogFile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write a job log file — writeLogFile","text":"","code":"if (FALSE) {     jstatuses <- sample(c(\"PEND\", \"RUN\", \"DONE\", \"EXIT\"), 10, replace = TRUE)     writeLogFile(jstatuses, Sys.time())     file.show( \"jobstatus.log\" )   }"},{"path":"/news/index.html","id":"mstoolkit-300","dir":"Changelog","previous_headings":"","what":"MSToolkit 3.0.0","title":"MSToolkit 3.0.0","text":"MSToolkit 3.0.0 development GitHub. 3.0.0 version removes NONMEM $PRED parsing related code. rationale behind try revert MSToolkit dedicated trial design simulation, analysis operating characteristic evaluation tool. simulation tools available simulate NONMEM models - example: Perl speaks NONMEM PsN. R-based simulation engines exist simulating systems differential equations. See example PKPDsim, RxODE mrgsolve. DDMoRe products allow user simulate MDL / PharmML models using tools PsN, simulx mlxR. MSToolkit 3.0.0 like focus trial design, leaving generation response outcomes tools, listed , unless response generating equations easy define analytically. Ultimately intention able link MSToolkit tools generate pipeline trial design, analysis evaluation operating characteristics.","code":""},{"path":"/news/index.html","id":"mstoolkit-200","dir":"Changelog","previous_headings":"","what":"MSToolkit 2.0.0","title":"MSToolkit 2.0.0","text":"MSToolkit 2.0.0 released public via R-Forge 29th June 2009. available via CRAN March 2013 orphaned. time MSToolkit required additional changes around handling parallel processing (moving Rlsf snow parallel) didn’t time address maintenance issues. hope MSToolkit GitHub community may assist fixing minor issues forking, changing code making pull request.","code":""},{"path":"/news/index.html","id":"mstoolkit-100","dir":"Changelog","previous_headings":"","what":"MSToolkit 1.0.0","title":"MSToolkit 1.0.0","text":"MSToolkit 1.0.0 designed Mike K Smith Pfizer developed Mango Solutions Pfizer. MSToolkit 1.0.0 internal release Pfizer.","code":""}]
